{
    "version": "https://jsonfeed.org/version/1",
    "title": "Chen • All posts by \"面试\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/07/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "http://example.com/2024/07/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "Java面试题",
            "date_published": "2024-07-14T01:56:54.000Z",
            "content_html": "<p>记录</p>\n<h1 id=\"java\"><a class=\"anchor\" href=\"#java\">#</a> Java</h1>\n<h2 id=\"1-jdk-jre-jvm-三者区别\"><a class=\"anchor\" href=\"#1-jdk-jre-jvm-三者区别\">#</a> 1. JDK、JRE、JVM 三者区别</h2>\n<p><img data-src=\"image-20240714100212330.png\" alt=\"image-20240714100212330\" /></p>\n<h2 id=\"2java-中创建对象的几种方式\"><a class=\"anchor\" href=\"#2java-中创建对象的几种方式\">#</a> 2.Java 中创建对象的几种方式？</h2>\n<ol>\n<li>使用 new 关键字：最常见的方式，这种方式我们还可以<strong>调用任意的构造器</strong> (无参的和有参的)</li>\n<li>使用 Class.newlnstance: 通过 Class 类的 newInstance 创建对象，必须有<strong> public 的无参构造器</strong>才行</li>\n<li>使用 Constructor.newlnstance: 通过 java.langrelect.Constructor 类中的 newlnstance 方法调用<strong>有参数的和私有的构造函数</strong>。</li>\n<li>使用 Clone: 通过对象的 clone0 方法创建一个对象的副本。需要<strong>对象实现 Cloneable 接口并重写 clone () 方法</strong>。</li>\n<li>使用反序列化：通过将对象转换为字节流并保存到文件或传输到网络，然后再从字节流中重新创建对象。需要对象<strong>实现 Serializable</strong></li>\n</ol>\n<h2 id=\"3final-finally-finalize-的区别\"><a class=\"anchor\" href=\"#3final-finally-finalize-的区别\">#</a> 3.final、finally、 finalize 的区别</h2>\n<ul>\n<li><strong>final 关键字：用于修饰类、方法、变量、入参和对象</strong><br />\n应用于类时，表示该类是最终类，不能被其他类继承，<br />\n 应用于方法时，表示该方法是最终方法，不能被子类重写<br />\n应用于变量时，表示该变量是一个常量，只能赋值一次。<br />\n应用于入参时，表示该入参在方法内无法被修改。<br />\n应用于对象时，该对象的引用不能被修改，但对象本身的状态是可变的。</li>\n<li><strong>finally 关键字：异常处理机制中的一部分，用于定义在 try-catch-finally 块中的 finally 块</strong><br />\n不论是否发生异常，finally 块中的代码都会执行<br />\n主要用于释放资源、关闭连接等必须确保执行的操作。</li>\n<li><strong>finalize 方法：是一个对象的方法，定义在 Object 类中</strong><br />\n在垃圾回收器将对象回收之前调用。<br />\n可以重写 finalize 方法，在其中编写对象在被回收前需要进行的清理操作，如释放资源等.<br />\n 请注意，不推荐使用 finalize 方法进行内存资源的释放，因为它没有被及时执行的保证，也可能导<br />\n致性能问题</li>\n</ul>\n<h2 id=\"5两个对象的-hashcode0-相同则-equals-也一定为-true-吗\"><a class=\"anchor\" href=\"#5两个对象的-hashcode0-相同则-equals-也一定为-true-吗\">#</a> 5. 两个对象的 hashCode0 相同，则 equals ( 也一定为 true 吗？</h2>\n<ul>\n<li>两个对象的 hashCode (相同，equals) 不一定为 true;</li>\n<li>两个对象的 equals 为 true，则两个对象的 hashcode 一定为 true</li>\n</ul>\n<h2 id=\"6-的区别\"><a class=\"anchor\" href=\"#6-的区别\">#</a> 6.&amp;、&amp;&amp;、|、|| 的区别</h2>\n<p>&amp; 全比较，&amp;&amp; 只要第一个不成立则不再判断</p>\n<h2 id=\"7java-中的参数传递时传值呢-还是传引用\"><a class=\"anchor\" href=\"#7java-中的参数传递时传值呢-还是传引用\">#</a> 7.Java 中的参数传递时传值呢？还是传引用？</h2>\n<p>在 Java 中，方法参数传递是按值传递的。这意味着在方法调用时，实际上是将参数的值进行拷贝并传递给方法内部使用，而不是直接传递参数本身的引用。</p>\n<ul>\n<li>对于<strong>基本数据类型</strong> (如整数、浮点数等):<strong> 传递的是其值的拷贝</strong>。任何对参数值的修改都不会影响原始变量。</li>\n<li>对于 ** 引用类型 (** 如对象、数组等):<strong> 传递的是引用的值的拷贝</strong>，也就是说方法内部的参数和原始变量将引用同一个对象。虽然我们可以通过方法内部的参数修改对象的状态，但是对于引用本身的修改是不会影响原始变量的。</li>\n</ul>\n<h2 id=\"8什么是-java-的序列化如何实现-java-的序列化\"><a class=\"anchor\" href=\"#8什么是-java-的序列化如何实现-java-的序列化\">#</a> 8. 什么是 Java 的序列化，如何实现 Java 的序列化？</h2>\n<p>定义:<strong> 序列化是指将一个对象转换为字节流</strong>，以便在网络上传输或保存到文件中。序列化过程还可以通过反序列化将字节流重新转换为对象</p>\n<p>实现方式：通过<strong>实现 java.io.Serializable 接口</strong>。该接口是一个<strong>标记接口</strong>，没有任何方法定义，只要一个类实现了 Serializable 接口，就表示该类的对象可以被序列化。Java 序列化机制会根据对象的类结构自动进行序列化和反序列化操作。</p>\n<h2 id=\"9java-中的反射是什么意思\"><a class=\"anchor\" href=\"#9java-中的反射是什么意思\">#</a> 9.Java 中的反射是什么意思？</h2>\n<p>Java 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制</p>\n<p>简单的说：在运行时动态地获取、操作和修改类或对象的属性、方法、构造函数等信息的能力，而不需要在编译时预先知道类的具体信息</p>\n<p><img data-src=\"image-20240714120514087.png\" alt=\"image-20240714120514087\" /></p>\n<h2 id=\"10反射的应用场景有哪些-反射有什么优缺点\"><a class=\"anchor\" href=\"#10反射的应用场景有哪些-反射有什么优缺点\">#</a> 10. 反射的应用场景有哪些？反射有什么优缺点？</h2>\n<h3 id=\"应用场景\"><a class=\"anchor\" href=\"#应用场景\">#</a> <strong>应用场景</strong></h3>\n<p>反射是 Java 框架的灵魂技术，很多框架都使用了反射技术，如 spring，Mybatis，Hibernate 等.</p>\n<p><strong>JDBC 的数据库的连接</strong><br />\n在 JDBC 连接数据库中，一般包括加载驱动，获得数据库连接等步骤。而加载驱动，就是引入相关 Jar 包后，通过 Class.forName (加载数据库的驱动程序<br />\n Class.forName (&quot;com.mysgl.cj.jdbc.Driver&quot;):</p>\n<p><strong>xml 或 properties 等配置文件加载</strong></p>\n<p><strong>Spring 通过 XML 配置模式装载 Bean，也是反射的一个典型例子</strong></p>\n<p><strong>装载过程:</strong></p>\n<ul>\n<li>将程序内 XML 配置文件加载入内存中</li>\n<li>Java 类解析 xml 或者 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>\n<li>使用反射机制，得到 Class 实例</li>\n<li>动态配置实例的属性</li>\n</ul>\n<p>这样做当然是有好处的不用每次都去 new 实例了，并且可以修改配置文件，比较灵活。</p>\n<h3 id=\"反射的优点\"><a class=\"anchor\" href=\"#反射的优点\">#</a> <strong>反射的优点</strong></h3>\n<p>** 动态性:** 反射提供了在运行时动态地探索和操作类的能力。它允许我们在运行时获取类的信息、创建对象、调用方法和修改字段的值，从而使程序更加灵活、可扩展和动态适应复杂环境：：反射可以应对一些复杂的场景，如在插件化系统中根据配置文件加载类、动态代理、识别和处理注解等</p>\n<h3 id=\"反射的缺点\"><a class=\"anchor\" href=\"#反射的缺点\">#</a> <strong>反射的缺点</strong></h3>\n<p>** 性能问题:** 由于反射涉及到动态解析和调用，所以它通常比直接调用代码性能较低。反射需要进行额外的检查和处理，可能会导致性能下降<br />\n ** 安全问题:** 反射可以绕过访问控制限制，例如访问私有方法和字段。这可能会导致安全隐患，因此在使用反射时需要小心处理，并确保只在必要情况下使用</p>\n<h2 id=\"11怎么实现动态代理\"><a class=\"anchor\" href=\"#11怎么实现动态代理\">#</a> 11. 怎么实现动态代理？</h2>\n<p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能</p>\n<p>动态代理实现方式:</p>\n<ul>\n<li>JDK 实现: JDK Proxy 基于反射</li>\n<li>第三方类实现: CGLIB 基于 ASM (一个 Java 字节码操作框架)</li>\n</ul>\n<h3 id=\"如何实现动态代理\"><a class=\"anchor\" href=\"#如何实现动态代理\">#</a> 如何实现动态代理</h3>\n<ul>\n<li>基于接口的 JDK 动态代理\n<ul>\n<li>定义目标类，即被代理的类</li>\n<li>通过实现 InvocationHandler 接口来自定义自己的 InvocationHandler; 重写 invoke 方法，在此方法中定义增强逻辑。</li>\n<li>通过 Proxy.newProxylnstance 方法获得代理对象</li>\n<li>通过代理对象调用目标方法</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"image-20240714122259992.png\" alt=\"image-20240714122259992\" /></p>\n<p><img data-src=\"image-20240714122522237.png\" alt=\"image-20240714122522237\" /></p>\n<ul>\n<li>基于类的 CGLIB 动态代理\n<ul>\n<li>引入 CGLIB 的相关依赖</li>\n<li>定义目标类，即被代理的类</li>\n<li>创建代理类实现 CGLIB 的 Methodinterceptor 接口，并重写 intercept 方法，在此方法中定义增强逻辑。</li>\n<li>使用 Enhancer 类创建代理对象，设置目标类、回调对象等参数</li>\n<li>调用代理对象的方法，实现代理行为。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"image-20240714122735661.png\" alt=\"image-20240714122735661\" /></p>\n<h3 id=\"jdk-proxy与cglib的区别\"><a class=\"anchor\" href=\"#jdk-proxy与cglib的区别\">#</a> <strong>JDK Proxy 与 CGLIB 的区别</strong></h3>\n<ul>\n<li>基于接口 vs. 基于类:<br />\nJDK Proxy <strong>只能代理接口类型</strong>，它通过实现指定接口并生成代理对象来实现代理功能<br />\n CGLIB <strong>可以代理普通的类</strong>，它通过继承目标类，并在子类中重写方法来实现代理。</li>\n<li>实现方式:<br />\nJDK Proxy 是<strong>基于反射机制</strong>实现的，它利用 Java 的反射 API 动态生成代理对象<br />\n CGLIB 使用了<strong>字节码生成库</strong>，直接操作字节码生成代理类。相比于 JDK 代理的反射调用，CGLIB 的方法调用更快速</li>\n<li>性能:<br />\n<strong> 由于 CGLIB 是直接对字节码进行操作，所以在创建和执行代理对象时通常比 JDK 代理更快速</strong><br />\n JDK Proxy 的性能略低，因为它涉及到反射调用的开销。JDK8 版本已经优化，性能与 CGLIB 差不多。</li>\n<li>库依赖:<br />\nJDK Proxy 是 Java 标准库的一部分，无需额外的依赖<br />\n CGLIB 需要引入相关的第三方库</li>\n</ul>\n<h2 id=\"12-string-为什么不可变\"><a class=\"anchor\" href=\"#12-string-为什么不可变\">#</a> 12. String 为什么不可变？</h2>\n<p>String 类本身是<strong> final</strong> 的，不可以被继承</p>\n<p>String 类内部通过 **private final char value []** 实现，从而保证了引用的不可变和对外的不可见</p>\n<p>String 内部通过良好的封装，不去改变 value 数组的值</p>\n<p><strong>为什么要设计成不可变？</strong></p>\n<ul>\n<li>字符串池优化：不可变性<strong>允许字符串共享和重用</strong>，节省内存空间和提高性能</li>\n<li>线程安全性：不可变类<strong>天然具备线程安全的特性</strong>，无需额外同步措施</li>\n<li>缓存哈希值：不可变性<strong>使得字符串的哈希值可以被缓存，提高相关数据结构的性能</strong>。</li>\n</ul>\n<p><strong>TIPS</strong></p>\n<p>可以用反射来改变 String 中 value 的值，所以严格意义上说不一定不可变。</p>\n<h2 id=\"13string-stringbuilder-stringbuffer-的区别\"><a class=\"anchor\" href=\"#13string-stringbuilder-stringbuffer-的区别\">#</a> 13.String、StringBuilder、StringBuffer 的区别？</h2>\n<ul>\n<li>\n<p>可变性:</p>\n<ul>\n<li>String 类是不可变类，一旦创建就无法改变其内容。对于每次修改操作 (例如拼接字符串)，都会创建一个新的字符串对象，旧对象则成为垃圾数据，需要等待垃圾回收。它们可以直接在原始对象上进行修改而不创建新的对象</li>\n<li>StringBuilder 和 StringBuffer 类是可变的，这种特性使得在频繁拼接或修改字符串时更高效。</li>\n</ul>\n</li>\n<li>\n<p>线程安全性:</p>\n<ul>\n<li>String 类是线程安全的，因为它的不可变性保证了多个线程同时访问同一个字符串对象时的安全性</li>\n<li><strong>StringBuilder 类是非线程安全的</strong>，它的方法没有进行同步处理。如果在多线程环境下使用 StringBuilder，需要额外来取措施保证线程安全</li>\n<li>StringBuffer 类是线程安全的，它的方法进行了同步处理，因此可以在多线程环境下使用</li>\n</ul>\n</li>\n<li>\n<p>性能:</p>\n<ul>\n<li>在单线程环境下，StringBuilder 的性能通常优于 StringBuffer，因为 StringBuilder 不进行同步处理，省去了同步的开销</li>\n<li>在多线程环境下，由于 StringBuffer 进行了同步处理，可能会带来额外的性能开销。但当线程同步是必需的时候，StringBuffer 是一个可靠的选择。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"image-20240714131415731.png\" alt=\"image-20240714131415731\" /></p>\n<h2 id=\"14-string-str-i与-string-str-new-stringi-一样吗\"><a class=\"anchor\" href=\"#14-string-str-i与-string-str-new-stringi-一样吗\">#</a> 14. String str = &quot;i&quot; 与 String str = new String (&quot;i&quot;) 一样吗？</h2>\n<p>不一样，因为内存的分配方式不一样。</p>\n<ul>\n<li>String str=&quot;i&quot; 的方式 JVM 会将其分配到<strong>常量池</strong>中；</li>\n<li>String str=new String (“i”) 方式，则会被分到<strong>堆内存</strong>中。</li>\n</ul>\n<h2 id=\"15-接口和抽象类有什么区别\"><a class=\"anchor\" href=\"#15-接口和抽象类有什么区别\">#</a> 15. 接口和抽象类有什么区别</h2>\n<ul>\n<li>\n<p>定义关键字不同</p>\n<ul>\n<li>接口使用关键字<strong> interface</strong> 来定义。抽象类使用关键字<strong> abstract</strong> 来定义</li>\n</ul>\n</li>\n<li>\n<p>继承或实现的关键字不同</p>\n<ul>\n<li>接口使用<strong> implements</strong> 关键字定义其具体实现。 抽象类使用 **extends ** 关键字实现继承</li>\n</ul>\n</li>\n<li>\n<p>子类扩展的数量不同</p>\n<ul>\n<li>接口的实现类可以有多个</li>\n<li>抽象类的子类，只能继承一个抽象类，抽象类的子类，只能继承一个抽象类</li>\n</ul>\n</li>\n<li>\n<p>属性访问控制符不同，方法控制符不同</p>\n<ul>\n<li>接口中属性的访问控制符只能是 public (接口中的属性默认是 public static final 修饰的)</li>\n<li>抽象类中的属性访问控制符无限制，可为任意控制符</li>\n</ul>\n</li>\n<li>\n<p>tip：</p>\n<ul>\n<li>接口可<strong>继承</strong>多个父接口</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"16-什么是浅拷贝和深拷贝\"><a class=\"anchor\" href=\"#16-什么是浅拷贝和深拷贝\">#</a> 16. 什么是浅拷贝和深拷贝？</h2>\n<ul>\n<li>浅拷贝: <strong>只复制指向某个对象的指针</strong>，而不复制对象本身，新旧对象共享一块内存</li>\n<li>深拷贝: <strong>复制并创建一个一摸一样的对象</strong>，不共享内存，修改新对象，旧对象保持不变</li>\n</ul>\n<p><img data-src=\"image-20240714132445512.png\" alt=\"image-20240714132445512\" /></p>\n<h2 id=\"17-overload-override-overwrite的区别\"><a class=\"anchor\" href=\"#17-overload-override-overwrite的区别\">#</a> 17. Overload、Override、Overwrite 的区别？</h2>\n<p>在面向对象编程中，有三个概念经常用到: Overload (重载)、Override (重写) 和 Overwrite (覆盖), 这些概念描述了不同的方法或函数之间的关系。</p>\n<p><strong>重载 (Overload) :</strong></p>\n<p>定义：在同一个类中，可以定义多个具有相同名称但参数列表不同的方法，它们被称为方法的重载</p>\n<p>特点:</p>\n<ul>\n<li><strong>方法名相同</strong>，参数列表不同</li>\n<li>重载方法可以有不同的返回类型</li>\n<li>重载方法必须在同一个类中</li>\n<li>重载方法的<strong>区分依据是参数</strong>的个数、类型或者顺序</li>\n</ul>\n<p><img data-src=\"image-20240714133843845.png\" alt=\"image-20240714133843845\" /></p>\n<p><strong>重写 (Override)</strong></p>\n<p>定义：子类继承自父类时，可以对父类的方法进行重新实现，这被称为方法的重写</p>\n<p>特点:</p>\n<ul>\n<li>子类中的方法与父类中的方法具有相同的名称、参数列表和返回类型</li>\n<li><strong>子类中的方法不能比父类的方法访问性更严格</strong></li>\n<li><strong>子类方法抛出的异常不能比父类方法抛出的异常更多</strong></li>\n<li>子类方法可以覆盖父类方法的实现，提供自己的实现逻辑</li>\n</ul>\n<p><img data-src=\"image-20240714133829892.png\" alt=\"image-20240714133829892\" /></p>\n<p><strong>覆盖 (Overwrite)</strong></p>\n<p>定义：在文件操作中，覆盖 (Overwrite) 通常指的是<strong>将已有的文件内容替换为新的内容</strong></p>\n<p>特点:</p>\n<ul>\n<li>覆盖通常发生在文件写入时，用新的内容覆盖原有的内容，使其被替代</li>\n<li>覆盖可能会导致原文件的内容丢失，因此在进行覆盖操作时要小心。</li>\n</ul>\n<h2 id=\"18-exception和error有什么区别\"><a class=\"anchor\" href=\"#18-exception和error有什么区别\">#</a> 18. Exception 和 Error 有什么区别？</h2>\n<p>在 Java 中，Exception 和 Error 是两个不同的类，它们<strong>都继承自 Throwable 类</strong>。下面是它们之间的区别:</p>\n<p><strong>Exception (异常) :</strong></p>\n<p>Exception 表示在程序执行过程中可能出现的可处理的异常情况。** 它一般由代码逻辑错误、外部条件变化等原因引起，可以通过适当的处理措施来恢复正常的程序执行。**Exception 分为两种类型:</p>\n<ul>\n<li><strong>受检异常 (Checked Exception)</strong> : 编译器要求必须在代码中显式地处理受检异常，否则代码无法通过编译。常见的受检异常包括 IOException、SQLException 等。（用 try-catch-finally）</li>\n<li><strong>非受检异常 (Unchecked Exception)</strong> : 编译器对非受检异常不强制要求进行处理，但可以选择处理或者将其抛给上层调用者处理。常见的非受检异常包括 NullPointerException、ArrayIndexOutOfBoundsException 等</li>\n</ul>\n<p><strong>Error (错误)：</strong></p>\n<p>Error 是<strong>指应用程序通常无法处理或恢复的严重问题</strong>，如除零错误</p>\n<p>Error 通常表示<strong>虚拟机 (JVM) 的错误状态或系统级错误</strong>，例如 OutOfMemoryError、StackOverflowError 等</p>\n<p>Error 通常意味着应用程序处于不可恢复的状态，因此一般不被捕获和处理</p>\n<p>与异常不同，Error 没有规定要求应用程序处理或捕获它们。</p>\n<h2 id=\"19-java中的io流的分类-说出几个你熟悉的实现类\"><a class=\"anchor\" href=\"#19-java中的io流的分类-说出几个你熟悉的实现类\">#</a> 19. Java 中的 IO 流的分类？说出几个你熟悉的实现类？</h2>\n<p>在 Java 中，10 流可以根据其功能和作用进行分类。主要分为四种类型：字节流、字符流、缓冲流和对象流</p>\n<p><img data-src=\"image-20240714134749700.png\" alt=\"image-20240714134749700\" /></p>\n<p><strong>字节流 (Byte Stream):</strong> <strong>以字节为单位进行读写操作的流</strong>。字节流通常用于处理二进制数据或字节流形式的文本数据。</p>\n<ul>\n<li>InputStream: 字节输入流的抽象基类，是所有字节输入流的超类</li>\n<li>OutputStream: 字节输出流的抽象基类，是所有字节输出流的超类</li>\n<li>一些实现类包括: FilelnputStream、FileOutputStream、ByteArraylnputStream、ByteArrayOutputStream 等</li>\n</ul>\n<p><strong>字符流 (Character Stream):</strong> <strong>以字符为单位进行读写操作的流</strong>。字符流通常用于处理字符数据，支持 Unicode 编码。</p>\n<ul>\n<li>Reader: 字符输入流的抽象基类，是所有字符输入流的超类</li>\n<li>Writer: 字符输出流的抽象基类，是所有字符输出流的超类</li>\n<li>一些实现类包括: FileReader、FileWriter、BufferedReader、PrintWriter 等</li>\n</ul>\n<p><strong>缓冲流 (Buffered Stream)</strong> : 提供了<strong>缓冲功能</strong>，可以减少实际 IO 操作的次数，提高读写效率</p>\n<ul>\n<li>BufferedInputStream: 字节缓冲输入流，装饰器模式实现</li>\n<li>BufferedOutputStream: 字节缓冲输出流，装饰器模式实现</li>\n<li>BufferedReader: 字符缓冲输入流，装饰器模式实现</li>\n<li>BufferedWriter: 字符缓冲输出流，装饰器模式实现</li>\n</ul>\n<p><strong>对象流 (Object Stream)</strong>:  <strong>用于读写 Java 对象的流</strong>。可以方便地将对象序列化和反序列化到文件或网络中</p>\n<ul>\n<li>ObjectlnputStream: 对象输入流，用于从流中读取对象</li>\n<li>ObjectOutputStream: 对象输出流，用于将对象写入流</li>\n</ul>\n<h2 id=\"20-常见的异常类有哪些\"><a class=\"anchor\" href=\"#20-常见的异常类有哪些\">#</a> 20. 常见的异常类有哪些？</h2>\n<p>RuntimeException (运行时异常)</p>\n<ul>\n<li>NullPointerException: 空指针异常，当对一个对象引用调用方法或访问属性时，对象引用为空</li>\n<li>ArraylndexOutOfBoundsException: 数组下标越界异常，当尝试访问数组的不存在的索引时抛出</li>\n<li>lllegalArgumentException: 非法参数异常，当传递给方法的参数不合法时抛出</li>\n<li>lllegalStateException: 非法状态异常，当对象处于不允许的状态下调用方法时抛出</li>\n</ul>\n<p>IOException (输入输出异常) :</p>\n<ul>\n<li>FileNotFoundException: 文件未找到异常，当尝试打开不存在的文件时抛出</li>\n<li>EOFException: 文件结束异常，当从数据流读取数据时到达文件末尾时抛出</li>\n<li>SocketException: 套接字异常，当与套接字相关的操作失败时抛出</li>\n</ul>\n<p>SQLException (数据库异常) :</p>\n<ul>\n<li>SQLSyntaxErrorException: SQL 语法错误异常，当执行 SQL 语句时遇到语法错误时抛出</li>\n<li>DataAccessException: 数据访问异常，当访问数据库或数据存储出现问题时抛出</li>\n</ul>\n<p>ClassNotFoundException: 类未找到异常，当尝试加载不存在的类时抛出</p>\n<h2 id=\"22-arraylist和linkedlist区别\"><a class=\"anchor\" href=\"#22-arraylist和linkedlist区别\">#</a> 22. ArrayList 和 LinkedList 区别</h2>\n<ul>\n<li>底层数据结构不同，ArrayList 底层是基于数组实现的，LinkedList 底层是基于链表实现的</li>\n<li>由于底层数据结构不同，他们所适用的场景也不同，ArrayList 更适合随机查找，Linkedlist 更适合删除和添加，查询、添加、删除的时间复杂度不同</li>\n<li>另外 Arravlist 和 LinkedList 都实现了 List 接口，但是 LinkedList 还额外实现了 Deque 接口，所以 LinkedlList 还可以当做队列来使用</li>\n</ul>\n<h2 id=\"24-copyonwritearraylist的底层原理是怎样的\"><a class=\"anchor\" href=\"#24-copyonwritearraylist的底层原理是怎样的\">#</a> 24. CopyOnWriteArrayList 的底层原理是怎样的</h2>\n<ul>\n<li>首先 CopyOnWriteArrayList 内也是用时数组来实现的，在向 CopyOnWriteArrayList 添元索时，会复制一个新的数组，<strong>写操作在新数进行，读操作在原数组上进行</strong></li>\n<li>并且，<strong>写操作会加锁</strong>，防止出现并发写入丢失数据的问题</li>\n<li><strong>写操作结束之后会把原数组指向新数组</strong></li>\n<li>CopyOnWiteArraylist<strong> 允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场</strong>，但是 CopyOnWiteAraylist 会比较占内存，同时可能读到的数据不是实时最新的数据，所以不<strong>适合实时性要求很高的场景</strong></li>\n</ul>\n<h2 id=\"30-hashmap的扩容机制原理\"><a class=\"anchor\" href=\"#30-hashmap的扩容机制原理\">#</a> 30. HashMap 的扩容机制原理</h2>\n<p><strong>1.7 版本</strong></p>\n<ol>\n<li>先生成新数组</li>\n<li>遍历老数组中的每个位置上的链表上的每个元素</li>\n<li>取每个元素的 key，并基于新数组长度，计算出每个元素在新数组中的下标</li>\n<li>将元素添加到新数组中去</li>\n<li>所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性</li>\n</ol>\n<p><strong>1.8 版本</strong></p>\n<ol>\n<li>先生成新数组</li>\n<li>遍历老数组中的每个位置上的链表或红黑树</li>\n<li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</li>\n<li>如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置\n<ol>\n<li>统计每个下标位置的元素个数</li>\n<li>如果该位置下的元素个数超过了 8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置</li>\n<li>如果该位置下的元素个数没有超过 8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置</li>\n</ol>\n</li>\n<li>所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性</li>\n</ol>\n<p>Tips:</p>\n<p>1.7 版本的 hash 链表的部分是头插法，不需要遍历到尾部，更快</p>\n<p>1.8 版本的 hash 链表的部分是尾插法，因为要判断是否大于 8，大于 8 就转换成红黑树，而知道数量需要遍历链表，则用尾插法</p>\n<h2 id=\"32-java死锁如何避免\"><a class=\"anchor\" href=\"#32-java死锁如何避免\">#</a> 32. Java 死锁如何避免</h2>\n<p><strong>造成死锁的几个原因</strong></p>\n<ul>\n<li>一个资源每次只能被一个线程使用</li>\n<li>一个线程在阻塞等待某个资源时，不释放已占有资源</li>\n<li>一个线程已经获得的资源，在未使用完之前，不能被强行剥夺</li>\n<li>若干线程形成头尾相接的循环等待资源关系</li>\n</ul>\n<p>这是造成死锁必须要达到的 4 个条件，如果要避免死锁，只需要不满足其中某一个条件即可。</p>\n<p>而其中前 3 个条件是作为锁要符合的条件，所以要避免死执就需要打破第 4 个条件，不出现循环等待锁的关系</p>\n<p>在开发过程中:</p>\n<ul>\n<li>要注意<strong>加锁顺序</strong>，保证每个线程按同样的顺序进行加锁</li>\n<li>要注意加锁时限，可以针对所设置一个<strong>超时时间</strong></li>\n<li>要注意<strong>死锁检查</strong>，这是一种预防机制，确保在第一时间发现死锁并进行解决</li>\n</ul>\n<h2 id=\"34-java中有哪些类加载器\"><a class=\"anchor\" href=\"#34-java中有哪些类加载器\">#</a> 34. Java 中有哪些类加载器</h2>\n<p>JDK 自带有三个类加载器: bootstrap ClassLoader、ExtClassLoader、AppClassLoader。</p>\n<ul>\n<li>BootStrapClassLoader 是 ExtClassLoader 的父类加载器，默认负责加载 % JAVA HOME% lib 下的 iar 包和 cass 文件</li>\n<li>ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载 % JAVA HOME%/lib/ext 文件夹下的 jar 包和 class 类</li>\n<li>AppClassLoader 是自定义类加载器的父类，负责加载 lasspath 下的类文件</li>\n</ul>\n<h2 id=\"39-和的区别是什么\"><a class=\"anchor\" href=\"#39-和的区别是什么\">#</a> 39. #{} 和 ${} 的区别是什么？</h2>\n<p>#{} 是预编译处理、是占位符，${} 是字符串替换、是拼接符。</p>\n<p>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为？号，调用 PreparedStatement 来赋值</p>\n<p>Mybatis 在处理<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow></mrow><mtext>时，会将</mtext><mi>s</mi><mi>q</mi><mi>l</mi><mtext>中的</mtext></mrow><annotation encoding=\"application/x-tex\">{}时，会将sql中的</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">会</span><span class=\"mord cjk_fallback\">将</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">的</span></span></span></span> {} 替换成变量的值，调用 Statement 来赋值</p>\n<p>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性</p>\n<h2 id=\"60-sychronized和reentrantlock的区别\"><a class=\"anchor\" href=\"#60-sychronized和reentrantlock的区别\">#</a> 60. Sychronized 和 ReentrantLock 的区别</h2>\n<ul>\n<li>Sychronized 是一个<strong>关键字</strong>，ReentrantLock 是一个类</li>\n<li>Sychronized 会<strong>自动的加锁与释放锁</strong>，ReentrantLock 需要程序员手动加锁与释放锁</li>\n<li>Sychronized 的底层是<strong> JVM 层面的锁</strong>，ReentrantLock 是<strong> API 层面的锁</strong></li>\n<li>Sychronized 是<strong>非公平锁</strong>，ReentrantLock<strong> 可以选择公平锁或非公平锁</strong></li>\n<li>Sychronized 锁的是对象，锁信息保存在对象头中，ReentrantLock 通过代码中 int 类型的 state 标识来标识锁的状态</li>\n<li>Sychronized 底层有一个锁升级的过程</li>\n</ul>\n<h2 id=\"java类的加载过程\"><a class=\"anchor\" href=\"#java类的加载过程\">#</a> Java 类的加载过程</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTYzOTEyL2FydGljbGUvZGV0YWlscy8xMTY2NDI1NTY=\">请你说说 Java 类的加载过程_说说类加载的流程 - CSDN 博客</span></p>\n<ol>\n<li>什么是类的加载过程</li>\n<li>一个 Java 文件从编码完成到最终运行，一般会经历两个阶段：编译期、运行期。编译，即通过 javac 命令，将 Java 文件转化为二进制字节码文件，即.class 文件；运行，则是将.class 文件交给 JVM 执行。而本文所说的类加载过程就是将.class 文件中类的元信息加载进内存，创建 Class 对象并进行解析、初始化类变量等的过程<br />\n​    JVM 并不是一开始就会将所有的类加载到内存，而是用到某个类，才会去加载，只加载一次，后续会说到类的加载时机</li>\n<li>类加载详解</li>\n<li>类加载分为三个部分：<strong>加载、连接、初始化</strong></li>\n</ol>\n<p><strong>2.1 加载</strong></p>\n<p>​        类的加载主要的职责为将.class 文件的二进制字节流读入内存 (JDK1.7 及之前为 JVM 内存，JDK1.8 及之后为本地内存)，并在堆内存中为之创建 Class 对象，作为.class 进入内存后的数据的访问入口。在这里只是读入二进制字节流，后续的验证阶段就是要拿二进制字节流来验证.class 文件，验证通过，才会将.class 文件转为运行时数据结构</p>\n<p><strong>2.2 连接</strong></p>\n<p>类的连接分为三个阶段：<strong>验证、准备、解析</strong>。</p>\n<p><strong>验证</strong>：该阶段主要是为了保证加载进来的字节流符合 JVM 的规范，不会对 JVM 有安全性问题。其中有对元数据的验证，例如检查类是否继承了被 final 修饰的类；还有对符号引用的验证，例如校验符号引用是否可以通过全限定名找到，或者是检查符号引用的权限 (private、public) 是否符合语法规定等。</p>\n<p><strong>准备</strong>：准备阶段的主要任务是为类的类变量开辟空间并赋默认值。</p>\n<ol>\n<li>静态变量是基本类型（int、long、short、char、byte、boolean、float、double）的默认值为 0</li>\n<li>静态变量是引用类型的，默认值为 null</li>\n<li>静态常量默认值为声明时设定的值</li>\n</ol>\n<p>例如：public static final int i = 3; 在准备阶段，i 的值即为 3</p>\n<p><strong>解析</strong>：该阶段的主要职责为将 Class 在常量池中的符号引用转变为直接引用，此处针对的是静态方法及属性和私有方法与属性，因为这类方法与私有方法不能被重写，静态属性在运行期也没有多态这一说，即在编译器可知，运行期不可变，所以适合在该阶段解析，譬如类方法 main 替换为直接引用，为静态连接，区别于运行时的动态连接 (后续我会写关于 JVM 内存结构的文章，在讲解栈帧时会介绍动态链接)。</p>\n<p>符号引用即字符串，说白了可以是一个字段名，或者一个方法名；直接引用即偏移量，说白了就是类的元信息位于内存的地址串，例如，一个类的方法为 test ()，则符号引用即为 test，这个方法存在于内存中的地址假设为 0x123456，则这个地址则为直接引用。</p>\n<p><strong>2.3 初始化</strong></p>\n<p>该阶段主要是为类的类变量初始化值的，初始化有两种方式：</p>\n<ol>\n<li>在声明类变量时，直接给变量赋值</li>\n<li>在静态初始化块为类变量赋值</li>\n</ol>\n<h2 id=\"java锁有哪些sychronized是什么锁\"><a class=\"anchor\" href=\"#java锁有哪些sychronized是什么锁\">#</a> java 锁有哪些，Sychronized 是什么锁</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdjaGVuc3VpeXVlL2FydGljbGUvZGV0YWlscy8xMDg3MTY0NjY=\">Java 中常见的各种锁（非常全）_java 滑块锁 - CSDN 博客</span></p>\n<p><img data-src=\"image-20240802153419417.png\" alt=\"image-20240802153419417\" /></p>\n<h2 id=\"线程创建方式\"><a class=\"anchor\" href=\"#线程创建方式\">#</a> 线程创建方式</h2>\n<ul>\n<li>方式一：继承于 Thread 类</li>\n<li>方式二：实现 Runnable 接口</li>\n<li>方式三：实现 Callable 接口</li>\n<li>方式四：使用线程池</li>\n<li>方式五：使用匿名类</li>\n</ul>\n<h1 id=\"数据结构\"><a class=\"anchor\" href=\"#数据结构\">#</a> 数据结构</h1>\n<h2 id=\"跳表\"><a class=\"anchor\" href=\"#跳表\">#</a> 跳表</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwcGxlZWF0aW5nYm95L2FydGljbGUvZGV0YWlscy8xMTk5NDgzNDA=\">跳表的原理与实现 </span></p>\n<p>将<strong>单链表先进行排序</strong>，然后针对 <strong>有序链表</strong> 为了实现高效的查找，可以使用跳表这种数据结构。</p>\n<p>其根本思想是 <strong>二分查找</strong> 的思想。</p>\n<p>跳表的前提条件是 针对 <strong>有序的单链表</strong> ，实现高效地查找，插入，删除。</p>\n<p>Redis 中的 有序集合 <strong>sorted set</strong> 就是用跳表实现的。</p>\n<h1 id=\"mysql-redis\"><a class=\"anchor\" href=\"#mysql-redis\">#</a> MySQL、Redis</h1>\n<h2 id=\"mysql索引实现有哪些\"><a class=\"anchor\" href=\"#mysql索引实现有哪些\">#</a> MySQL 索引实现有哪些</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2NzAxNS9hcnRpY2xlL2RldGFpbHMvMTE5MTA5Mzg1\">MySQL 索引的概念以及七种索引类型介绍_什么是数据库索引，mysql 常见的索引类型有哪些？-CSDN 博客</span></p>\n<h3 id=\"1-索引的概念\"><a class=\"anchor\" href=\"#1-索引的概念\">#</a> 1 索引的概念</h3>\n<p>索引（在 MySQL 中也叫做 “键（key）”）是存储引擎用于快速找到记录的一种数据结构，这也是索引最基本的功能。</p>\n<p>索引对于良好的性能非常关键。数据量越大时，索引对性能的影响也越重要，好的索引可以将查询性能提高几个数量级。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但是在数据量逐渐增大时，糟糕的索引会使 MySQL 的性能急剧的下降。</p>\n<p>索引优化是查询性能优化最有效的手段。</p>\n<h3 id=\"2-索引的类型\"><a class=\"anchor\" href=\"#2-索引的类型\">#</a> 2 索引的类型</h3>\n<p>按照功能逻辑区分，MySQL 目前主要有以下索引类型：</p>\n<ul>\n<li><strong>主键索引</strong>\n<ul>\n<li>数据列不允许重复，不允许为 NULL，一个表只能有一个主键。</li>\n<li>ALTER TABLE table_name ADD PRIMARY KEY (column);</li>\n</ul>\n</li>\n<li><strong>普通索引</strong>\n<ul>\n<li>MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和 NULL 值。一个表允许多个列创建普通索引。</li>\n<li>ALTER TABLE table_name ADD INDEX index_name (column);</li>\n</ul>\n</li>\n<li><strong>唯一索引</strong>\n<ul>\n<li>索引列中的值必须是唯一的，但是允许 NULL 值。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。一个表允许多个列创建唯一索引。</li>\n<li>ALTER TABLE table_name ADD UNIQUE (column);</li>\n</ul>\n</li>\n<li><strong>全文索引</strong>\n<ul>\n<li>主要是为了快速检索大文本数据中的关键字的信息。字段长度比较大时，如果创建普通索引，在进行 like 模糊查询时效率比较低，这时可以创建全文索引，基于倒排索引，类似于搜索引擎。MyISAM 存储引擎支持全文索引，InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li>\n<li>ALTER TABLE table_name ADD FULLTEXT (column);</li>\n</ul>\n</li>\n<li><strong>前缀索引</strong>\n<ul>\n<li>在文本类型如 BLOB、TEXT 或者很长的 VARCHAR 列上创建索引时，可以使用前缀索引，数据量相比普通索引更小，可以指定索引列的长度，但是数值类型不能指定。</li>\n<li>ALTER TABLE table_name ADD KEY(column_name(prefix_length));</li>\n</ul>\n</li>\n<li><strong>组合索引</strong>\n<ul>\n<li>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则。</li>\n<li>主键索引、普通索引、唯一索引等都可以使用多个字段形成组合索引。例如，ALTER TABLE table_name ADD INDEX index_name (column1, column2, column3);</li>\n</ul>\n</li>\n<li><strong>空间索引</strong>\n<ul>\n<li>MySQL 在 5.7 之后的版本支持了空间索引，而且支持 OpenGIS 几何数据模型。MySQL 在空间索引这方面遵循 OpenGIS 几何数据模型规则。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mysql索引有哪些实现方式\"><a class=\"anchor\" href=\"#mysql索引有哪些实现方式\">#</a> MySQL 索引有哪些实现方式</h3>\n<p>什么是 B+Tree 索引，B+Tree 索引的构建过程，跟二叉树、红黑树的对比</p>\n<p>为什么数据库存储用 B+tree 索引，局部性原理是什么，为什么推荐自增 id</p>\n<p>MySQL 有哪些索引，聚集索引，二级索引，覆盖索引区别，回表是什么</p>\n<p>怎么加索引，索引的使用场景有哪些，加索引一定好吗</p>\n<p>索引失效的场景，引发什么后果</p>\n<p>EXPLAIN 关键字查看 MySQL 是否使用索引</p>\n<h2 id=\"23-b树和b树的区别为什么mysql使用b树\"><a class=\"anchor\" href=\"#23-b树和b树的区别为什么mysql使用b树\">#</a> 23. B 树和 B + 树的区别，为什么 Mysql 使用 B + 树</h2>\n<p><strong>B 树的特点</strong></p>\n<ul>\n<li>节点排序</li>\n<li>一个节点可以存多个元素，多个元素也排序了</li>\n</ul>\n<p><strong>B + 树的特点</strong></p>\n<ul>\n<li>拥有 B 例的特点</li>\n<li>子节点之间有指钊</li>\n<li>非叶子节点上的元素仙叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序</li>\n</ul>\n<p>Mysq 索引使用的是 B+，因为索引是用来加快查询的，而 B + 树通过对数据排序所以是可以提高查询速度的</p>\n<p>然后通过一个节点中可以有储多个元素，从而可以使得 B + 树的高度不会太高，在 Mysql 中一个 Innodb 页就是一个 B + 树节点，一 Innodb 页默认 16kb，所以一般情况下一颗两层的 B + 可以存 2000 万行左右的数</p>\n<p>然后通过利用 B + 树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，以微了的支持全表描，范围查找等 SQL 语句</p>\n<h2 id=\"38-mybatis的优缺点\"><a class=\"anchor\" href=\"#38-mybatis的优缺点\">#</a> 38. Mybatis 的优缺点</h2>\n<p><strong>优点:</strong></p>\n<ul>\n<li>基于 SOL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>\n<li>与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量几余的代码，不需要手动开关连接；</li>\n<li>很好的与各种数据库兼容 (因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持)</li>\n<li>能够与 Spring 很好的集成</li>\n<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射，提供对象关系映射标签，支持对象关系组件维护</li>\n</ul>\n<p><strong>缺点:</strong></p>\n<ul>\n<li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求</li>\n<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>\n</ul>\n<h2 id=\"40-mysql慢查询该如何优化\"><a class=\"anchor\" href=\"#40-mysql慢查询该如何优化\">#</a> 40. Mysql 慢查询该如何优化？</h2>\n<ul>\n<li>检查是否走了索引，如果没有则优化 SQL 利用索引</li>\n<li>检查所利用的索引，是否是最优索引</li>\n<li>检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据检查表中数据是否过多，是否应该进行分库分表了</li>\n<li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源</li>\n</ul>\n<h2 id=\"41-mysql锁有哪些如何理解\"><a class=\"anchor\" href=\"#41-mysql锁有哪些如何理解\">#</a> 41. Mysql 锁有哪些，如何理解</h2>\n<ul>\n<li>按锁粒度分类\n<ul>\n<li>行锁：锁某行数据，锁粒度最小，并发度高</li>\n<li>表锁：锁整张表，锁粒度最大，并发度低</li>\n<li>间隙锁：锁的是一个区间</li>\n</ul>\n</li>\n<li>读写分类\n<ul>\n<li>共享锁：也就是读锁。一个事务给某行数据加了读锁，其他事务也可以读，但是不能写</li>\n<li>排它锁：也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写</li>\n</ul>\n</li>\n<li>还可以分为\n<ul>\n<li>乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的</li>\n<li>悲观锁：上面所的行锁、表锁等都是悲观锁</li>\n</ul>\n</li>\n<li>在事务的隔离级别实现中，就需要利用锁来解决幻读</li>\n</ul>\n<h2 id=\"42-redis和mysql如何保证数据一致\"><a class=\"anchor\" href=\"#42-redis和mysql如何保证数据一致\">#</a> 42. Redis 和 Mysql 如何保证数据一致</h2>\n<ul>\n<li><strong>先更新 Mysql，再更新 Redis</strong>，如果更新 Redis 失败，可能仍然不一致</li>\n<li><strong>先删除 Redis 存数据，再更新 Mysql</strong>，再次查询的时候在将数据添加到存中，这种方案能解决 1 方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程 1 删除了 Redis 缓存数据，正在更新 Mysql，此时另外一个查询再查询，那么就会把 Mysql 中老数据又查到 Redis 中</li>\n<li><strong>延时双删</strong>，步骤是：先删除 Redis 存数据，再更新 Mysql，延几百毫秒再删除 Redis 存数据，这样就算在更新 Mysql 时，有其他线程读了 Mysql，把老教据读到了 Redis 中，那么也会被删除掉，从而把数据保持一致</li>\n</ul>\n<h2 id=\"43-redis有哪些数据结构-分别有哪些典型的应用场景\"><a class=\"anchor\" href=\"#43-redis有哪些数据结构-分别有哪些典型的应用场景\">#</a> 43. Redis 有哪些数据结构？分别有哪些典型的应用场景？</h2>\n<p>Redis 的数据结构有:</p>\n<ul>\n<li><strong>字符串 string</strong>: 可以用来做最简单的数，可以存某个简单的字符串，也可以存某个 json 格式的字符审，Redis 分布式锁的实现就利用了这种数结构，还包括可以实现计数器、Session 共享、分布式 ID</li>\n<li><strong>哈希表 hash</strong>: 可以用来存储一些 key-value 对，更适合用来存储对象</li>\n<li><strong>列表 list</strong>: Redis 的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li>\n<li><strong>集合 set</strong>: 和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能</li>\n<li><strong>有序集合 zset</strong>: 集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</li>\n</ul>\n<h2 id=\"mvcc机制rc级别解决脏读问题rr级别怎么解决不可重复读问题\"><a class=\"anchor\" href=\"#mvcc机制rc级别解决脏读问题rr级别怎么解决不可重复读问题\">#</a> MVCC 机制，RC 级别解决脏读问题，RR 级别怎么解决不可重复读问题</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RyYWNreGlhb3hpbjMyMS9hcnRpY2xlL2RldGFpbHMvMTIyMTU3MTcx\">一图看懂 MVCC 机制，RC 级别解决脏读问题，RR 级别怎么解决不可重复读问题【MySQL 系列】_mvcc 实现 rr 和读提交 - CSDN 博客</span></p>\n<p><strong>脏读是怎么产生的</strong>，即事务 A 更改了某条数据，事务 B 读取，随后事务因为某些原因回滚了，此时事务 B 读的数据就是 “脏数据”，称为脏读。产生脏读的原因也很简单，事务 B 读取了事务 A 未提交的数据。因此读已提交（只能读取事务提交后的数据）能解决脏读问题。</p>\n<p><strong>不可重复读问题</strong>，是事务 A 读取了某条数据，随后事务 B 更改了这条数据，事务 A 再次读取，发现数据不一致了（即使读已提交，也不能解决不可重复读问题，因为事务 B 如果已经提交了事务，此时读已提交隔离级别下是可以读到的，这里也涉及到了 MVCC 机制，后面会详细讲），因此读已提交解决不了不可重复读问题。</p>\n<p><strong>MVCC</strong>（Mutil-Version Concurrency Control）多版本并发控制机制，实现了 MySQL 在 InnoDB 引擎下 RC 级别和 RR 级别下对数据库的并发访问，每次 select 操作会访问数据库中的版本链记录，其他事务可以修改这条记录，而 select 根据当前隔离级别去版本链中找到对应的版本记录，实现了读 - 写，写 - 读的并发执行，提升了系统的性能。</p>\n<p>先解析三个概念，<strong>当前读、快照读和 ReadView</strong>。</p>\n<p><strong>当前读</strong>：读的都是最新版本的数据，会对数据进行加锁操作，防止其他事务修改当前数据。是悲观锁的一种实现方式。insert、update、select …for update、select…lock in share mode 都是当前读；</p>\n<p><strong>快照读</strong>：最普通的不加锁的 select 读到的数据，读到的不一定是最新数据，有可能是之前历史版本的数据；</p>\n<p><strong>ReadView</strong>：快照读的一种形式，MySQL 执行 MVCC 提取数据的依据；本质是一个数据结构，其中包括几下几个部分：</p>\n<ol>\n<li>m_ids：当前活跃的事务 ID 集合（开启但未提交的事务 ID）；</li>\n<li>min_trx_ids: 最小活跃事务 ID，小于它说明事务已经提交；</li>\n<li>max_trx_ids: 预分配的事务 ID（下一个事务开启分配的事务 ID），即当前最大事务 ID+1；大于它说明该事物是 ReadView 生成之后才开启；</li>\n<li>creator_trx_id:ReadView 创建者的事务编号；</li>\n</ol>\n<p><strong>版本链</strong>：MySQL 数据库中，每条数据除肉眼可见的数据之外，还有几个隐藏字段：<br />\n1.db_trx_id: 记录最近修改这条记录的事务 ID；<br />\n2.db_roll_pointer: 回滚指针，指向指向这条数据的上一个版本记录；<br />\n3.db_row_id: 隐藏的自增 ID（隐藏的自增主键），如果表没有主键，InnoDB 会自动以 db_row_id 生成主键索引；</p>\n<p>实际上，RC 和 RR 两个隔离级别，实现的主要区别在于 ReadView 的时机不一样，RC 隔离级别下，每次快照读都会生成一个 ReadView；而 RR 级别下，只有在第一次快照读时生成 ReadView，后面会延续使用；事务根据生成的 ReadView 去版本链中寻找自己能够访问的数据，最后得到所读的数据；而这个寻找可读数据的规则就至关重要了。</p>\n<h2 id=\"redis-16-个常见使用场景\"><a class=\"anchor\" href=\"#redis-16-个常见使用场景\">#</a> Redis 16 个常见使用场景</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fnb25pZTIwMTIxOC9hcnRpY2xlL2RldGFpbHMvMTIzNjQwODcx\">Redis 16 个常见使用场景_redis 用途 - CSDN 博客</span></p>\n<h2 id=\"分布式锁redisson的使用看门狗机制\"><a class=\"anchor\" href=\"#分布式锁redisson的使用看门狗机制\">#</a> 分布式锁 Redisson 的使用，看门狗机制</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5MTk0Mi9hcnRpY2xlL2RldGFpbHMvMTA3NTkxMTM3\">分布式锁 Redisson 的使用，看门狗机制_分布式锁使用了啥，看门狗机制，锁的默认超时时间是多少 - CSDN 博客</span></p>\n<h2 id=\"如何使用redis做一个定时任务\"><a class=\"anchor\" href=\"#如何使用redis做一个定时任务\">#</a> 如何使用 redis 做一个定时任务？</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1c2h1YW5naGFvMTIzL2FydGljbGUvZGV0YWlscy8xMTM4NTc4NjI=\">如何使用 redis 做一个定时任务？_redis 定时任务 - CSDN 博客</span></p>\n<h1 id=\"spring\"><a class=\"anchor\" href=\"#spring\">#</a> Spring</h1>\n<h2 id=\"21-applicationcontext和beanfactory有什么区别\"><a class=\"anchor\" href=\"#21-applicationcontext和beanfactory有什么区别\">#</a> 21. ApplicationContext 和 BeanFactory 有什么区别</h2>\n<p>BeanFactory 是 Spring 中非常核心的组件，表示 Bean 工厂，可以生成 bean，维护 bean，</p>\n<p>而 ApplicationContxt 继承了 Beanfactory，所以具有 BeanFactory 的特点。</p>\n<p>ApplicationContext 除了继承 BeanFactory 之外，还继承了诸如 EnvironmentCapable、MessageSource、ApplicationEventPublisher 等接口，从而 ApplicationContext 还有获取系统环境变量、国际化、事件发布等功能，这是 BeanFactory 不具备的。</p>\n<h2 id=\"48-spring-boot是如何启动tomcat的\"><a class=\"anchor\" href=\"#48-spring-boot是如何启动tomcat的\">#</a> 48. Spring Boot 是如何启动 Tomcat 的</h2>\n<ol>\n<li>首先，SpringBoot 在启动时会先创建一个 Spring 容器</li>\n<li>在创建 Spring 容器时程中，会 @ConditionalOnClass 技术来判新当前 classpath 中是否存在 Tomcat 依赖，如果存在会生成一个启动 Tomcat 的 Bean</li>\n<li>Spring 容器创建完之后，就会获取启动 Tomcat 的 Bean，并创建 Tomcat 对象，并绑定端口等，然后启动 Tomcat</li>\n</ol>\n<h2 id=\"49-spring-boot中常用注解及其底层实现\"><a class=\"anchor\" href=\"#49-spring-boot中常用注解及其底层实现\">#</a> 49. Spring Boot 中常用注解及其底层实现</h2>\n<ul>\n<li><strong>@SpringBootApplication</strong> 注解：这个注解标识了一个 SpringBoot 工程，它实际上是另外三个注解的组合，这三个注解是:\n<ul>\n<li><strong>@SpringBootConfiquration</strong>: 这个注解实际就是一个 @Configuration，表示启动类也是一个配置类</li>\n<li>@<strong>EnableAutoConfiquration</strong>: 向 Spring 容器中导入了一个 Selector，用来加载 ClassPath 下 SpringFatories 中所定义的自动配置类，将这些自动动载为配置 Bean</li>\n<li>@<strong>ComponentScan</strong>: 标识扫描路径，因为默认是没有配置实际扫描路径，所以 SpringBoot 扫描的路径是启动类所在的当前目录</li>\n</ul>\n</li>\n<li>@<strong>Bean</strong> 注解：用来定义 Bean，类似于 XML 中的 bean &gt; 标签，Spring 在启动时，会对加了 @Bean 注解的方法进行解折，将方法的名字做为 beanName，并通过执行方法得到 bean 对象</li>\n<li>@<strong>Controller</strong>、@<strong>Service</strong>、 @<strong>ResponseBody</strong>、@<strong>Autowired</strong> 等</li>\n</ul>\n<h2 id=\"52-spring-优点\"><a class=\"anchor\" href=\"#52-spring-优点\">#</a> 52. Spring 优点</h2>\n<ol>\n<li>\n<p><strong>轻量级</strong></p>\n</li>\n<li>\n<p><strong>控制反转（IOC）</strong>、依赖注入</p>\n</li>\n<li>\n<p><strong>切片编程（AOP）</strong></p>\n</li>\n<li>\n<p>容器</p>\n</li>\n<li>\n<p>MVC 框架</p>\n</li>\n<li>\n<p>事务管理</p>\n</li>\n<li>\n<p>异常处理</p>\n</li>\n<li>\n<p><strong>可拓展性</strong></p>\n</li>\n</ol>\n<h2 id=\"spring-ioc的理解\"><a class=\"anchor\" href=\"#spring-ioc的理解\">#</a> <strong>Spring IOC 的理解</strong></h2>\n<p>控制反转</p>\n<p>整个 IOC 容器创建的流程和步骤如下：</p>\n<ol>\n<li>向 bean 工厂中设置一些参数</li>\n<li>加载解析 bean 对象</li>\n<li>BeanPostProcessor 的注册功能</li>\n<li>通过反射的方式讲 BeanDefinition 对象实例化成具体的 bean 对象</li>\n<li>bean 对象的初始化过程</li>\n<li>生成完整的 bean 对象</li>\n<li>通过 getBean 方法可以直接获取</li>\n<li>销毁过程</li>\n</ol>\n<h2 id=\"spring-aop的理解\"><a class=\"anchor\" href=\"#spring-aop的理解\">#</a> <strong>spring AOP 的理解</strong></h2>\n<p>面向切面编程（AOP）：允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如<strong>日志管理和事务管理</strong>。</p>\n<p>在 Spring AOP 中，切面通过带有 **@Aspect** 注解的类实现</p>\n<p>通知 (Advice)：通知表示在方法执行前后需要执行的动作。实际上它是 Spring AOP 框架在程序执行过程中触发的一些代码。有前置通知、后置通知、环绕通知等</p>\n<p>动态代理：代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</p>\n<h2 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h2>\n<p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>\n<h3 id=\"事务的特性acid\"><a class=\"anchor\" href=\"#事务的特性acid\">#</a> <strong>事务的特性（ACID）</strong></h3>\n<ol>\n<li><strong>原子性</strong>（ <code>Atomicity</code> ）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性</strong>（ <code>Consistency</code> ）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>\n<li><strong>隔离性</strong>（ <code>Isolation</code> ）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性</strong>（ <code>Durability</code> ）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n<p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong></p>\n<h3 id=\"事务管理\"><a class=\"anchor\" href=\"#事务管理\">#</a> <strong>事务管理</strong></h3>\n<ol>\n<li><strong>编程式事务管理</strong></li>\n</ol>\n<p>通过  <code>TransactionTemplate</code>  或者 <code>TransactionManager</code>  手动管理事务，实际应用中很少使用</p>\n<ol start=\"2\">\n<li><strong>声明式事务管理</strong></li>\n</ol>\n<p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于 <code>@Transactional</code>  的全注解方式使用最多）。</p>\n<p>使用  <code>@Transactional</code>  注解进行事务管理的示例代码如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Transactional</span><span class=\"token punctuation\">(</span>propagation <span class=\"token operator\">=</span> <span class=\"token class-name\">Propagation</span><span class=\"token punctuation\">.</span><span class=\"token constant\">REQUIRED</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> aMethod <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">//do something</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token class-name\">B</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token class-name\">C</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  b<span class=\"token punctuation\">.</span><span class=\"token function\">bMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  c<span class=\"token punctuation\">.</span><span class=\"token function\">cMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"54-spring-事务什么时候会失效\"><a class=\"anchor\" href=\"#54-spring-事务什么时候会失效\">#</a> 54. Spring 事务什么时候会失效？</h2>\n<p>spring 事务的原理是 AOP，进行了切面增强，那么失效的根本原因是这个 AOP 不起作用了！常见情况有如下几种</p>\n<ul>\n<li>发生自调用，类里面使用 this 调用本类的方法 (this 通常省略)，此时这个 this 对象不是代理类，而是 UserService 对象本身！</li>\n<li>解决方法很简单，让那个 this 变成 UserService 的代理类即可！</li>\n<li>方法不是 public 的: @Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 法上，可以开启 AspectJ 代理模式</li>\n<li>数据库不支持事务</li>\n<li>没有被 spring 管理</li>\n<li>异常被吃掉，事务不会回滚 (或者抛出的异常没有被定义，默认为 RuntimeException)</li>\n</ul>\n<h2 id=\"55-spring中bean是线程安全的吗\"><a class=\"anchor\" href=\"#55-spring中bean是线程安全的吗\">#</a> 55. Spring 中 Bean 是线程安全的吗</h2>\n<p>Spring 本身并没有针对 Bean 做线程安全的处理，所以:</p>\n<ul>\n<li>如果 Bean 是无状态的，那么 Bean 则是线程安全的</li>\n<li>如果 Bean 是有状态的，那么 Bean 则不是线程安全的</li>\n</ul>\n<p>另外，Bean 是不是线程安全，跟 Bean 的作用域没有关系，Bean 的作用域只是表示 Bean 的生命周期范围，对于任何生命固期的 Bean 都是一个对象，这个对象是不是线程安全的，还是得看这个 Bean 对象本身。</p>\n<p>tips：</p>\n<p><strong>有状态对象 (Stateful Bean)</strong> ：就是 ** 有实例变量的对象，可以保存数据，是非线程安全的。** 每个用户有自己特有的一个实例，在用户的生存期内，bean 保持了用户的信息，即 “有状态”；一旦用户灭亡（调用结束或实例结束），bean 的生命期也告结束。即每个用户最初都会得到一个初始的 bean。</p>\n<p><strong>无状态对象 (Stateless Bean)</strong>：就是 ** 没有实例变量的对象，不能保存数据，是不变类，是线程安全的。**bean 一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean 的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态 bean。但无状态会话 bean 并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。</p>\n<h2 id=\"spring-configuration注解\"><a class=\"anchor\" href=\"#spring-configuration注解\">#</a> Spring @Configuration 注解</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlb3h5ay9hcnRpY2xlL2RldGFpbHMvNzk4MDAwMjA=\">Spring @Configuration 注解_springconfiguration 注解 - CSDN 博客</span></p>\n<p>从 <code>Spring3.0</code> ， <code>@Configuration</code>  用于定义配置类，可替换 <code>xml</code>  配置文件，被注解的类内部包含有一个或多个被 <code>@Bean</code>  注解的方法，这些方法将会被 <code>AnnotationConfigApplicationContext</code>  或 <code>AnnotationConfigWebApplicationContext</code>  类进行扫描，并用于构建 <code>bean</code>  定义，初始化 <code>Spring</code>  容器。</p>\n<p>注意： <code>@Configuration</code>  注解的配置类有如下要求：</p>\n<ol>\n<li>@Configuration 不可以是 <code>final</code>  类型；</li>\n<li>@Configuration 不可以是匿名类；</li>\n<li>嵌套的 configuration 必须是静态类。</li>\n</ol>\n<h2 id=\"spring中bean及bean的理解与new对象的区别\"><a class=\"anchor\" href=\"#spring中bean及bean的理解与new对象的区别\">#</a> Spring 中 Bean 及 @Bean 的理解与 new 对象的区别</h2>\n<p>spring 有一个 Ioc 容器：Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans。 一些对象创建和使用完毕之后不会被销毁，放进对象池（某种集合）以备下次使用，下次再需要这个对象，不 new，直接从池里取，节省时间，也就是说我们可以随时使用和销毁。</p>\n<p>同理 Spring 的 @Bean 注解用于告诉方法，产生一个 Bean 对象，然后这个 Bean 对象交给 Spring 管理。产生这个 Bean 对象的方法 Spring 只会调用一次，随后这个 Spring 将会将这个 Bean 对象放在自己的 IOC 容器中。</p>\n<p>而使用 new 关键字创建的对象属于强引用对象，所谓强引用，就是 jvm 垃圾回收机制永远不会回收这类对象，这时候需要手动移除引用。如果没有移除，这个对象将一直存在，久而久之，会引起内存泄露问题。</p>\n<p>垃圾回收 (Garbage Collection) 是 Java 虚拟机 (JVM) 垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。</p>\n<pre><code>   强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。\n\n  new对象是因为类的构造方法一旦被修改，new的对象就出错了，如果是用了spring，就不用理会构造方法是否被修改，而拿来用就可以。\n</code></pre>\n<p>总的来说：Bean 和 new 但是创建对象，但是 Bean 所创建的对象会集中放在一个容器中方便管理</p>\n<h2 id=\"autowired-与resource的区别详细\"><a class=\"anchor\" href=\"#autowired-与resource的区别详细\">#</a> @Autowired 与 @Resource 的区别（详细）</h2>\n<p>@Resource 的作用相当于 @Autowired，只不过 **@Autowired 按 byType 自动注入 **，而 **@Resource 默认按 byName 自动注入 ** 罢了。</p>\n<p><strong>@Resource 有两个属性是比较重要的，分是 name 和 type</strong>，Spring 将 @Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不指定 name 也不指定 type 属性，这时将通过反射机制使用 byName 自动注入策略。</p>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://example.com/2024/06/23/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/",
            "url": "http://example.com/2024/06/23/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/",
            "title": "第二次面试准备",
            "date_published": "2024-06-23T08:42:22.000Z",
            "content_html": "<h1 id=\"第二次面试准备\"><a class=\"anchor\" href=\"#第二次面试准备\">#</a> 第二次面试准备</h1>\n<p>我的简历，又又又优化了一下</p>\n<p><img data-src=\"image-20240623164731985.png\" alt=\"image-20240623164731985\" /></p>\n<h2 id=\"了解一下公司\"><a class=\"anchor\" href=\"#了解一下公司\">#</a> 了解一下公司</h2>\n<h3 id=\"公司介绍\"><a class=\"anchor\" href=\"#公司介绍\">#</a> 公司介绍</h3>\n<ul>\n<li>云行计划技术布道者</li>\n<li>成立于 2009 年，坐落于杭州湾畔，我们自认为是中国比较优秀的互联网服务提供商。自成立以来，专注于<strong>云计算技术、移动互联应用、B/S 架构系统研发</strong>，为企业客户的互联网应用提供一站式服务。</li>\n</ul>\n<p>（来自 boss）</p>\n<h3 id=\"官网\"><a class=\"anchor\" href=\"#官网\">#</a> 官网</h3>\n<p><img data-src=\"image-20240623165735071.png\" alt=\"image-20240623165735071\" /></p>\n<p>这个地方加载的很慢，如何优化</p>\n<p>&lt;img src=&quot;image-20240623165917959.png&quot; alt=&quot;image-20240623165917959&quot;/&gt;</p>\n<h2 id=\"岗位要求\"><a class=\"anchor\" href=\"#岗位要求\">#</a> 岗位要求</h2>\n<ul>\n<li>扎实的 Java</li>\n<li>熟练使用 Linux</li>\n<li>熟练 Mysql、PostgreSQL</li>\n<li>Spring、Dubbo</li>\n</ul>\n<h2 id=\"自我介绍\"><a class=\"anchor\" href=\"#自我介绍\">#</a> 自我介绍</h2>\n<h2 id=\"项目\"><a class=\"anchor\" href=\"#项目\">#</a> <strong>项目</strong></h2>\n<h2 id=\"基础知识\"><a class=\"anchor\" href=\"#基础知识\">#</a> 基础知识</h2>\n<h3 id=\"redis\"><a class=\"anchor\" href=\"#redis\">#</a> Redis</h3>\n<p>见 面试准备一 以及 Redis 学习记录</p>\n<h3 id=\"linux\"><a class=\"anchor\" href=\"#linux\">#</a> Linux</h3>\n<p>……</p>\n<h3 id=\"java\"><a class=\"anchor\" href=\"#java\">#</a> Java</h3>\n<p>……</p>\n<h3 id=\"spring-postgresql\"><a class=\"anchor\" href=\"#spring-postgresql\">#</a> Spring、<s>PostgreSQL</s></h3>\n<h4 id=\"什么是spring框架spring框架有哪些主要模块\"><a class=\"anchor\" href=\"#什么是spring框架spring框架有哪些主要模块\">#</a> 什么是 Spring 框架？Spring 框架有哪些主要模块？</h4>\n<p>Spring 是一个<strong>轻量级的 JavaEE 框架</strong>，它主要解决企业应用中的复杂性问题。</p>\n<p>Spring 框架有三个核心部分: <strong>lOC 容器、AOP 和数据访问 / 集成层。</strong></p>\n<p>lOC 容器提供了一种对象创建和对象之间关系管理的机制，以实现松散耦合和可扩展性，</p>\n<p>AOP 提供了一种很好的方式来实现横向关注点的处理，如事务管理，安全检查，缓存等。</p>\n<p>数据访问 / 集成层则提供了许多针对不同数据持久化技术的实现，比如 JDBC，ORM 和 NoSQL。</p>\n<p>Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成、Web、AOP (面向切面编程)、工具、消息和测试模块</p>\n<p><strong>生态、基石</strong></p>\n<p><img data-src=\"image-20240623192514857.png\" alt=\"image-20240623192514857\" /></p>\n<h4 id=\"spring优点\"><a class=\"anchor\" href=\"#spring优点\">#</a> Spring 优点</h4>\n<ol>\n<li>\n<p><strong>轻量级</strong></p>\n</li>\n<li>\n<p><strong>控制反转（IOC）</strong>、依赖注入</p>\n</li>\n<li>\n<p><strong>切片编程（AOP）</strong></p>\n</li>\n<li>\n<p>容器</p>\n</li>\n<li>\n<p>MVC 框架</p>\n</li>\n<li>\n<p>事务管理</p>\n</li>\n<li>\n<p>异常处理</p>\n</li>\n<li>\n<p><strong>可拓展性</strong></p>\n</li>\n</ol>\n<h4 id=\"谈一下你对于springioc的理解\"><a class=\"anchor\" href=\"#谈一下你对于springioc的理解\">#</a> 谈一下你对于 springIOC 的理解</h4>\n<p>控制反转</p>\n<p>整个 IOC 容器创建的流程和步骤如下：向 bean 工厂中设置一些参数、加载解析 bean 对象、BeanPostProcessor 的注册功能、通过反射的方式讲 BeanDefinition 对象实例化成具体的 bean 对象、bean 对象的初始化过程、生成完整的 bean 对象，通过 getBean 方法可以直接获取、销毁过程</p>\n<h4 id=\"bean的生命周期\"><a class=\"anchor\" href=\"#bean的生命周期\">#</a> bean 的生命周期</h4>\n<p>……</p>\n<h4 id=\"自动装配的各种模式\"><a class=\"anchor\" href=\"#自动装配的各种模式\">#</a> 自动装配的各种模式</h4>\n<ul>\n<li>\n<p><strong>byName</strong></p>\n</li>\n<li>\n<p>byType、constructor</p>\n</li>\n<li>\n<p>autodetect、no</p>\n</li>\n</ul>\n<h4 id=\"beanfactory和applicationcontext有什么区别\"><a class=\"anchor\" href=\"#beanfactory和applicationcontext有什么区别\">#</a> BeanFactory 和 ApplicationContext 有什么区别？</h4>\n<p>加载：BeanFactory 采用的是 ** 延迟加载（lazy-loading）** 的方式，即只有在使用到某个 Bean 时 才会对该 Bean 进行加载和实例化。而 ApplicationContext 则是在容器启动 时，<strong>一次性创建所有的 Bean</strong>。</p>\n<p>创建：BeanFactory 通常以<strong>编程的方式创建</strong>，需要手动编写代码来配置和获取 Bean。而 ApplicationContext 除了支持编程方式创建外，还支持<strong>声明方式创建</strong>，如使用 XML 配置文件或注解 来配置 Bean。</p>\n<p>功能：ApplicationContext 接口作为 BeanFactory 的<strong>派生</strong>，不仅提供了 BeanFactory 所具有的功 能，还提供了更完整的框架功能。</p>\n<h4 id=\"spring-aop的理解\"><a class=\"anchor\" href=\"#spring-aop的理解\">#</a> spring AOP 的理解</h4>\n<p>面向切面编程（AOP）：允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如<strong>日志管理和事</strong> 务管理。</p>\n<p>在 Spring AOP 中，切面通过带有 **@Aspect** 注解的类实现</p>\n<p>通知 (Advice)：通知表示在方法执行前后需要执行的动作。实际上它是 Spring AOP 框架在程序执行过程 中触发的一些代码。有前置通知、后置通知、环绕通知等</p>\n<p>动态代理：代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样 的。</p>\n<h4 id=\"spring中用到了哪些设计模式\"><a class=\"anchor\" href=\"#spring中用到了哪些设计模式\">#</a> spring 中用到了哪些设计模式</h4>\n<ul>\n<li>单例模式：bean 默认都是单例的</li>\n<li>原型模式：指定作用域为 prototype</li>\n<li>工厂模式：BeanFactory</li>\n<li>模板方法：postProcessBeanFactory,onRefresh,initPropertyValue</li>\n<li>策略模式：XmlBeanDefinitionReader,PropertiesBeanDefinitionReader</li>\n<li>观察者模式：listener，event，multicast</li>\n<li>适配器模式：Adapter</li>\n<li>装饰者模式：BeanWrapper</li>\n<li>责任链模式：使用 aop 的时候会先生成一个拦截器链</li>\n<li>代理模式：动态代理</li>\n<li>委托者模式：delegate</li>\n</ul>\n<h3 id=\"mysql\"><a class=\"anchor\" href=\"#mysql\">#</a> MySQL</h3>\n<ul>\n<li>索引：b + 树、哈希、位图</li>\n<li>MySQL 优化：索引、查询优化（少子查询、模糊查询、全表查询）、表结构优化、缓存优化（Redis）、硬件优化</li>\n<li>慢查询：查询花费时间很多的日志</li>\n<li>死锁：避免大量查询、给事务加锁、增加悲观锁、设置合理超时时间</li>\n<li>优化大量数据插入：每一次插入的数量变多（合适数量），避免死锁，占用大量系统资源，磁盘空间</li>\n</ul>\n<h3 id=\"dubbo\"><a class=\"anchor\" href=\"#dubbo\">#</a> <s>Dubbo</s></h3>\n<p><s>随着互联网的发展，<strong>网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行</strong>，亟需一个治理系统确保架构有条不紊的演进。</s></p>\n<p><s>Apache Dubbo 最初是为了解决<strong>阿里巴巴内部的微服务架构问题</strong>而设计并开发的，最早在 2008 年，阿里巴巴就将 Dubbo 捐献到开源社区。在 2017 年，Dubbo 被正式捐献 Apache 软件基金会并成为 Apache 顶级项目，开始了一段新的征程。</s></p>\n<h4 id=\"为什么需要-dubbo它能做什么\"><a class=\"anchor\" href=\"#为什么需要-dubbo它能做什么\">#</a> <s>为什么需要 Dubbo，它能做什么？</s></h4>\n<p><s>按照微服务架构的定义，采用它的组织能够很好的提高业务迭代效率与系统稳定性，但前提是要先能保证微服务按照期望的方式运行，要做到这一点需要解决服务拆分与定义、数据通信、地址发现、流量管理、数据一致性、系统容错能力等一系列问题。</s></p>\n<p><s>Dubbo 可以帮助解决如下微服务实践问题：</s></p>\n<ul>\n<li><s><strong>微服务编程范式和工具</strong></s></li>\n</ul>\n<p><s>Dubbo 支持基于 IDL 或语言特定方式的服务定义，提供多种形式的服务调用形式（如同步、异步、流式等）</s></p>\n<ul>\n<li><s><strong>高性能的 RPC 通信</strong></s></li>\n</ul>\n<p><s>Dubbo 帮助解决微服务组件之间的通信问题，提供了基于 HTTP、HTTP/2、TCP 等的多种高性能通信协议实现，并支持序列化协议扩展，在实现上解决网络连接管理、数据传输等基础问题。</s></p>\n<ul>\n<li><s><strong>微服务监控与治理</strong></s></li>\n</ul>\n<p><s>Dubbo 官方提供的服务发现、动态配置、负载均衡、流量路由等基础组件可以很好的帮助解决微服务基础实践的问题。除此之外，您还可以用 Admin 控制台监控微服务状态，通过周边生态完成限流降级、数据一致性、链路追踪等能力。</s></p>\n<ul>\n<li><s><strong>部署在多种环境</strong></s></li>\n</ul>\n<p><s>Dubbo 服务可以直接部署在容器、Kubernetes、Service Mesh 等多种架构下。</s></p>\n<ul>\n<li><s><strong>活跃的社区</strong></s></li>\n</ul>\n<p><s>Dubbo 项目托管在 Apache 社区，有来自国际、国内的活跃贡献者维护着超 10 个生态项目，贡献者包括来自海外、阿里巴巴、工商银行、携程、蚂蚁、腾讯等知名企业技术专家，确保 Dubbo 及时解决项目缺陷、需求及安全漏洞，跟进业界最新技术发展趋势。</s></p>\n<ul>\n<li><s><strong>庞大的用户群体</strong></s></li>\n</ul>\n<p><s>Dubbo3 已在阿里巴巴成功落地，实现了对老版本 HSF2 框架全面升级，成为阿里集团面向云原生时代的统一服务框架底座，庞大的用户群体是 Dubbo 保持稳定性、需求来源、先进性的基础。</s></p>\n<h4 id=\"dubbo-不是什么\"><a class=\"anchor\" href=\"#dubbo-不是什么\">#</a> <s>Dubbo 不是什么？</s></h4>\n<ul>\n<li><s><strong>不是应用开发框架的替代者</strong></s></li>\n</ul>\n<p><s>Dubbo 设计为让开发者以主流的应用开发框架的开发模式工作，它不是各个语言应用开发框架的替代者，如它不是 Spring/Spring Boot 的竞争者，当你使用 Spring 时，Dubbo 可以无缝的与 Spring &amp; Spring Boot 集成在一起。</s></p>\n<ul>\n<li><s><strong>不仅仅只是一款 RPC 框架</strong></s></li>\n</ul>\n<p><s>Dubbo 提供了内置 RPC 通信协议实现，但它不仅仅是一款 RPC 框架。首先，它不绑定某一个具体的 RPC 协议，开发者可以在基于 Dubbo 开发的微服务体系中使用多种通信协议；其次，除了 RPC 通信之外，Dubbo 提供了丰富的服务治理能力与生态。</s></p>\n<ul>\n<li><s><strong>不是 gRPC 协议的替代品</strong></s></li>\n</ul>\n<p><s>Dubbo 支持基于 gRPC 作为底层通信协议，在 Dubbo 模式下使用 gRPC 可以带来更好的开发体验，享有统一的编程模型和更低的服务治理接入成本</s></p>\n<ul>\n<li><s><strong>不只有 Java 语言实现</strong></s></li>\n</ul>\n<p><s>自 Dubbo3 开始，Dubbo 提供了 Java、Golang、Rust、Node.js 等多语言实现，未来会有更多的语言实现。</s></p>\n<h2 id=\"知识拓展\"><a class=\"anchor\" href=\"#知识拓展\">#</a> 知识拓展</h2>\n<h2 id=\"引用\"><a class=\"anchor\" href=\"#引用\">#</a> 引用</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5kdWJiby5hcGFjaGUub3JnL3poLWNuL292ZXJ2aWV3L3doYXQv\">Dubbo 介绍 | Apache Dubbo</span></p>\n",
            "tags": [
                "面试"
            ]
        },
        {
            "id": "http://example.com/2024/04/12/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/",
            "url": "http://example.com/2024/04/12/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/",
            "title": "第一次面试准备",
            "date_published": "2024-04-12T04:15:51.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>大概三月末的时候，学校有个招聘会，然后我投了几家。刚刚打电话，问我明早有没有时间远程面试</p>\n<p>没多想就答应了下来，这下好了，得回顾一下简历上写的东西了</p>\n<p>对的，很烂</p>\n<p><img data-src=\"image-20240412121818555.png\" alt=\"image-20240412121818555\" /></p>\n<p>想着把 Redis 看一下（其实我还没学完，当时想着做简历就写上去了，而且最近在忙着比赛和打游戏，Java 这方面已经落下很多了）</p>\n<p>也许到时候可以把面试官往我最近比赛的方面引。</p>\n<h1 id=\"可能的面试内容\"><a class=\"anchor\" href=\"#可能的面试内容\">#</a> 可能的面试内容</h1>\n<p>时间紧任务重，能准备的也不是很充分</p>\n<h2 id=\"自我介绍\"><a class=\"anchor\" href=\"#自我介绍\">#</a> <s>自我介绍</s></h2>\n<p>……</p>\n<h2 id=\"redis项目的细节\"><a class=\"anchor\" href=\"#redis项目的细节\">#</a> Redis 项目的细节 *</h2>\n<ul>\n<li>\n<p>五种类型</p>\n<p>字符串、列表、hash、set、zset</p>\n</li>\n<li>\n<p>持久化策略</p>\n<p>…</p>\n</li>\n<li>\n<p>内存淘汰策略</p>\n<p>懒惰性删除 + 定期删除，懒惰性：用的时候才查是否过期。缺点：可能会有数据一直用不到，一直存在在内存。定期删除：定期删，缺点：遍历，时间长，内存压力大</p>\n<p>结合：抽取一部分定期删除 + 懒惰</p>\n</li>\n<li>\n<p>主从、哨兵</p>\n<p>主服务器、从服务器，</p>\n<p>哨兵：监控、提醒、自动故障迁移、统一的配置管理</p>\n</li>\n<li>\n<p>其他见 <em>Redis 学习记录</em></p>\n</li>\n</ul>\n<h2 id=\"spring-boot的相关知识\"><a class=\"anchor\" href=\"#spring-boot的相关知识\">#</a> Spring boot 的相关知识</h2>\n<p><img data-src=\"image-20240412231410321.png\" alt=\"image-20240412231410321\" /></p>\n<p><img data-src=\"image-20240412231458213.png\" alt=\"image-20240412231458213\" /></p>\n<h2 id=\"最近比赛的内容\"><a class=\"anchor\" href=\"#最近比赛的内容\">#</a> 最近比赛的内容</h2>\n<p>见 <em>A25</em></p>\n<h2 id=\"git\"><a class=\"anchor\" href=\"#git\">#</a> Git</h2>\n<p><img data-src=\"image-20240412231950813.png\" alt=\"image-20240412231950813\" /></p>\n<p><img data-src=\"image-20240412232258004.png\" alt=\"image-20240412232258004\" /></p>\n<h1 id=\"面后整理\"><a class=\"anchor\" href=\"#面后整理\">#</a> 面后整理</h1>\n<h2 id=\"自我介绍-2\"><a class=\"anchor\" href=\"#自我介绍-2\">#</a> 自我介绍</h2>\n<p>阿巴阿巴</p>\n<h2 id=\"问我什么项目提升最大redis\"><a class=\"anchor\" href=\"#问我什么项目提升最大redis\">#</a> 问我什么项目提升最大（Redis）</h2>\n<p>我说了 Redis 的那个，介绍一下项目实现，因为没有开视频，我对着昨晚做的 Redis 讲 + 分布式锁</p>\n<p>（懂不懂一天速成 Redis 的含金量 后仰.jpg）</p>\n<h2 id=\"mysql\"><a class=\"anchor\" href=\"#mysql\">#</a> Mysql</h2>\n<p>索引、having、group by</p>\n<h2 id=\"mybatis配置文件\"><a class=\"anchor\" href=\"#mybatis配置文件\">#</a> MyBatis 配置文件</h2>\n<p>Mysql 配置，MyBatis 插件的配置类……</p>\n<h2 id=\"spring-boot\"><a class=\"anchor\" href=\"#spring-boot\">#</a> Spring Boot</h2>\n<p>AOP（可恶，看了的没问，没看的忘了）</p>\n<h2 id=\"java基础\"><a class=\"anchor\" href=\"#java基础\">#</a> Java 基础</h2>\n<p>ArrayList 和 LinkedList 区别：</p>\n<ul>\n<li>ArrayList 基于动态数组实现的非线程安全的集合；LinkedList 基于链表实现的非线程安全的集合。</li>\n<li>对于随机 index 访问的 get 和 set 方法，一般 ArrayList 的速度要优于 LinkedList。因为 ArrayList 直接通过数组下标直接找到元素；LinkedList 要移动指针遍历每个元素直到找到为止。</li>\n</ul>\n<h2 id=\"问我什么课感兴趣\"><a class=\"anchor\" href=\"#问我什么课感兴趣\">#</a> 问我什么课感兴趣</h2>\n<p>我说了 Java + 操作系统 + 数据结构</p>\n<ul>\n<li>\n<p>操作系统</p>\n<p>银行家算法</p>\n</li>\n</ul>\n<h2 id=\"git工具\"><a class=\"anchor\" href=\"#git工具\">#</a> git 工具</h2>\n<p>常用命令</p>\n<h2 id=\"最近比赛的内容-2\"><a class=\"anchor\" href=\"#最近比赛的内容-2\">#</a> 最近比赛的内容</h2>\n<p>因为我时不时提一嘴，我最近在打比赛，然后后面终于问了。<strong>之前在牛客学的精髓，引导面试官占据主导权</strong></p>\n<p>这我可太熟了，然后问我参数的意义</p>\n<h2 id=\"由于涉及到ai问我ai对我们it行业的帮助\"><a class=\"anchor\" href=\"#由于涉及到ai问我ai对我们it行业的帮助\">#</a> 由于涉及到 AI，问我 AI 对我们 IT 行业的帮助</h2>\n<p>弱 AI，基于大数据而不是逻辑，所以只能辅助开发，而非独立开发</p>\n<h2 id=\"结尾\"><a class=\"anchor\" href=\"#结尾\">#</a> 结尾</h2>\n<p>问了一下我的情况</p>\n<h2 id=\"感想\"><a class=\"anchor\" href=\"#感想\">#</a> 感想</h2>\n<p>上次双选会，哥们就拿着之前做好的简历过去投，啥也没准备</p>\n<p>所以这一次算是第一次面试，昨天接到电话后一直在准备（虽然也玩了好些），但确实是半天速成 Redis，把敲代码的过程大部分跳了，然后关注原理，并记录。看完后昨晚看了一遍记录，今天看了一遍。</p>\n<p>然后再对着简历，准备了俩 Spring Boot 高频考点，粗看了一下 Git。早上还很早就醒了，害怕，jpg</p>\n",
            "tags": [
                "面试"
            ]
        }
    ]
}