{
    "version": "https://jsonfeed.org/version/1",
    "title": "Chen • All posts by \"java\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/07/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "http://example.com/2024/07/14/Java%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "Java面试题",
            "date_published": "2024-07-14T01:56:54.000Z",
            "content_html": "<p>记录</p>\n<h2 id=\"1-jdk-jre-jvm-三者区别\"><a class=\"anchor\" href=\"#1-jdk-jre-jvm-三者区别\">#</a> 1. JDK、JRE、JVM 三者区别</h2>\n<p><img data-src=\"image-20240714100212330.png\" alt=\"image-20240714100212330\" /></p>\n<h2 id=\"2java-中创建对象的几种方式\"><a class=\"anchor\" href=\"#2java-中创建对象的几种方式\">#</a> 2.Java 中创建对象的几种方式？</h2>\n<ol>\n<li>使用 new 关键字：最常见的方式，这种方式我们还可以<strong>调用任意的构造器</strong> (无参的和有参的)</li>\n<li>使用 Class.newlnstance: 通过 Class 类的 newInstance 创建对象，必须有<strong> public 的无参构造器</strong>才行</li>\n<li>使用 Constructor.newlnstance: 通过 java.langrelect.Constructor 类中的 newlnstance 方法调用<strong>有参数的和私有的构造函数</strong>。</li>\n<li>使用 Clone: 通过对象的 clone0 方法创建一个对象的副本。需要<strong>对象实现 Cloneable 接口并重写 clone () 方法</strong>。</li>\n<li>使用反序列化：通过将对象转换为字节流并保存到文件或传输到网络，然后再从字节流中重新创建对象。需要对象<strong>实现 Serializable</strong></li>\n</ol>\n<h2 id=\"3final-finally-finalize-的区别\"><a class=\"anchor\" href=\"#3final-finally-finalize-的区别\">#</a> 3.final、finally、 finalize 的区别</h2>\n<ul>\n<li><strong>final 关键字：用于修饰类、方法、变量、入参和对象</strong><br />\n应用于类时，表示该类是最终类，不能被其他类继承，<br />\n 应用于方法时，表示该方法是最终方法，不能被子类重写<br />\n应用于变量时，表示该变量是一个常量，只能赋值一次。<br />\n应用于入参时，表示该入参在方法内无法被修改。<br />\n应用于对象时，该对象的引用不能被修改，但对象本身的状态是可变的。</li>\n<li><strong>finally 关键字：异常处理机制中的一部分，用于定义在 try-catch-finally 块中的 finally 块</strong><br />\n不论是否发生异常，finally 块中的代码都会执行<br />\n主要用于释放资源、关闭连接等必须确保执行的操作。</li>\n<li><strong>finalize 方法：是一个对象的方法，定义在 Object 类中</strong><br />\n在垃圾回收器将对象回收之前调用。<br />\n可以重写 finalize 方法，在其中编写对象在被回收前需要进行的清理操作，如释放资源等.<br />\n 请注意，不推荐使用 finalize 方法进行内存资源的释放，因为它没有被及时执行的保证，也可能导<br />\n致性能问题</li>\n</ul>\n<h2 id=\"4-null\"><a class=\"anchor\" href=\"#4-null\">#</a> 4.  null</h2>\n<p>pass</p>\n<h2 id=\"5两个对象的-hashcode0-相同则-equals-也一定为-true-吗\"><a class=\"anchor\" href=\"#5两个对象的-hashcode0-相同则-equals-也一定为-true-吗\">#</a> 5. 两个对象的 hashCode0 相同，则 equals ( 也一定为 true 吗？</h2>\n<ul>\n<li>两个对象的 hashCode (相同，equals) 不一定为 true;</li>\n<li>两个对象的 equals 为 true，则两个对象的 hashcode 一定为 true</li>\n</ul>\n<h2 id=\"6-的区别\"><a class=\"anchor\" href=\"#6-的区别\">#</a> 6.&amp;、&amp;&amp;、|、|| 的区别</h2>\n<p>&amp; 全比较，&amp;&amp; 只要第一个不成立则不再判断</p>\n<h2 id=\"7java-中的参数传递时传值呢-还是传引用\"><a class=\"anchor\" href=\"#7java-中的参数传递时传值呢-还是传引用\">#</a> 7.Java 中的参数传递时传值呢？还是传引用？</h2>\n<p>在 Java 中，方法参数传递是按值传递的。这意味着在方法调用时，实际上是将参数的值进行拷贝并传递给方法内部使用，而不是直接传递参数本身的引用。</p>\n<ul>\n<li>对于<strong>基本数据类型</strong> (如整数、浮点数等):<strong> 传递的是其值的拷贝</strong>。任何对参数值的修改都不会影响原始变量。</li>\n<li>对于 ** 引用类型 (** 如对象、数组等):<strong> 传递的是引用的值的拷贝</strong>，也就是说方法内部的参数和原始变量将引用同一个对象。虽然我们可以通过方法内部的参数修改对象的状态，但是对于引用本身的修改是不会影响原始变量的。</li>\n</ul>\n<h2 id=\"8什么是-java-的序列化如何实现-java-的序列化\"><a class=\"anchor\" href=\"#8什么是-java-的序列化如何实现-java-的序列化\">#</a> 8. 什么是 Java 的序列化，如何实现 Java 的序列化？</h2>\n<p>定义:<strong> 序列化是指将一个对象转换为字节流</strong>，以便在网络上传输或保存到文件中。序列化过程还可以通过反序列化将字节流重新转换为对象</p>\n<p>实现方式：通过<strong>实现 java.io.Serializable 接口</strong>。该接口是一个<strong>标记接口</strong>，没有任何方法定义，只要一个类实现了 Serializable 接口，就表示该类的对象可以被序列化。Java 序列化机制会根据对象的类结构自动进行序列化和反序列化操作。</p>\n<h2 id=\"9java-中的反射是什么意思\"><a class=\"anchor\" href=\"#9java-中的反射是什么意思\">#</a> 9.Java 中的反射是什么意思？</h2>\n<p>Java 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制</p>\n<p>简单的说：在运行时动态地获取、操作和修改类或对象的属性、方法、构造函数等信息的能力，而不需要在编译时预先知道类的具体信息</p>\n<p><img data-src=\"image-20240714120514087.png\" alt=\"image-20240714120514087\" /></p>\n<h2 id=\"10反射的应用场景有哪些-反射有什么优缺点\"><a class=\"anchor\" href=\"#10反射的应用场景有哪些-反射有什么优缺点\">#</a> 10. 反射的应用场景有哪些？反射有什么优缺点？</h2>\n<p><strong>应用场景</strong><br />\n反射是 Java 框架的灵魂技术，很多框架都使用了反射技术，如 spring，Mybatis，Hibernate 等.</p>\n<p><strong>JDBC 的数据库的连接</strong><br />\n在 JDBC 连接数据库中，一般包括加载驱动，获得数据库连接等步骤。而加载驱动，就是引入相关 Jar 包后，通过 Class.forName (加载数据库的驱动程序<br />\n Class.forName (&quot;com.mysgl.cj.jdbc.Driver&quot;):</p>\n<p><strong>xml 或 properties 等配置文件加载</strong></p>\n<p><strong>Spring 通过 XML 配置模式装载 Bean，也是反射的一个典型例子</strong></p>\n<p><strong>装载过程:</strong></p>\n<ul>\n<li>将程序内 XML 配置文件加载入内存中</li>\n<li>Java 类解析 xml 或者 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>\n<li>使用反射机制，得到 Class 实例</li>\n<li>动态配置实例的属性</li>\n</ul>\n<p>这样做当然是有好处的不用每次都去 new 实例了，并且可以修改配置文件，比较灵活。</p>\n<p><strong>反射的优点:</strong><br />\n** 动态性:** 反射提供了在运行时动态地探索和操作类的能力。它允许我们在运行时获取类的信息、创建对象、调用方法和修改字段的值，从而使程序更加灵活、可扩展和动态适应复杂环境：：反射可以应对一些复杂的场景，如在插件化系统中根据配置文件加载类、动态代理、识别和处理注解等</p>\n<p><strong>反射的缺点:</strong><br />\n** 性能问题:** 由于反射涉及到动态解析和调用，所以它通常比直接调用代码性能较低。反射需要进行额外的检查和处理，可能会导致性能下降<br />\n ** 安全问题:** 反射可以绕过访问控制限制，例如访问私有方法和字段。这可能会导致安全隐患，因此在使用反射时需要小心处理，并确保只在必要情况下使用</p>\n<h2 id=\"11怎么实现动态代理\"><a class=\"anchor\" href=\"#11怎么实现动态代理\">#</a> 11. 怎么实现动态代理？</h2>\n<p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能</p>\n<p>动态代理实现方式:</p>\n<ul>\n<li>JDK 实现：JDK Proxy 基于反射</li>\n<li>第三方类实现: CGLIB 基于 ASM (一个 Java 字节码操作框架)</li>\n</ul>\n<p>如何实现动态代理:</p>\n<ul>\n<li>基于接口的 JDK 动态代理\n<ul>\n<li>定义目标类，即被代理的类</li>\n<li>通过实现 InvocationHandler 接口来自定义自己的 InvocationHandler; 重写 invoke 方法，在此方法中定义增强逻辑。</li>\n<li>通过 Proxy.newProxylnstance 方法获得代理对象</li>\n<li>通过代理对象调用目标方法</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"image-20240714122259992.png\" alt=\"image-20240714122259992\" /></p>\n<p><img data-src=\"image-20240714122522237.png\" alt=\"image-20240714122522237\" /></p>\n<ul>\n<li>基于类的 CGLIB 动态代理\n<ul>\n<li>引入 CGLIB 的相关依赖</li>\n<li>定义目标类，即被代理的类</li>\n<li>创建代理类实现 CGLIB 的 Methodinterceptor 接口，并重写 intercept 方法，在此方法中定义增强逻辑。</li>\n<li>使用 Enhancer 类创建代理对象，设置目标类、回调对象等参数</li>\n<li>调用代理对象的方法，实现代理行为。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"image-20240714122735661.png\" alt=\"image-20240714122735661\" /></p>\n<p><strong>JDK Proxy 与 CGLIB 的区别:</strong></p>\n<ul>\n<li>基于接口 vs. 基于类:<br />\nJDK Proxy <strong>只能代理接口类型</strong>，它通过实现指定接口并生成代理对象来实现代理功能<br />\n CGLIB <strong>可以代理普通的类</strong>，它通过继承目标类，并在子类中重写方法来实现代理。</li>\n<li>实现方式:<br />\nJDK Proxy 是<strong>基于反射机制</strong>实现的，它利用 Java 的反射 API 动态生成代理对象<br />\n CGLIB 使用了<strong>字节码生成库</strong>，直接操作字节码生成代理类。相比于 JDK 代理的反射调用，CGLIB 的方法调用更快速</li>\n<li>性能:<br />\n<strong> 由于 CGLIB 是直接对字节码进行操作，所以在创建和执行代理对象时通常比 JDK 代理更快速</strong><br />\n JDK Proxy 的性能略低，因为它涉及到反射调用的开销。JDK8 版本已经优化，性能与 CGLIB 差不多。</li>\n<li>库依赖:<br />\nJDK Proxy 是 Java 标准库的一部分，无需额外的依赖<br />\n CGLIB 需要引入相关的第三方库</li>\n</ul>\n<h2 id=\"12-string-为什么不可变\"><a class=\"anchor\" href=\"#12-string-为什么不可变\">#</a> 12. String 为什么不可变？</h2>\n<p>String 类本身是<strong> final</strong> 的，不可以被继承</p>\n<p>String 类内部通过 **private final char value []** 实现，从而保证了引用的不可变和对外的不可见</p>\n<p>String 内部通过良好的封装，不去改变 value 数组的值</p>\n<p><strong>为什么要设计成不可变？</strong></p>\n<ul>\n<li>字符串池优化：不可变性<strong>允许字符串共享和重用</strong>，节省内存空间和提高性能</li>\n<li>线程安全性：不可变类<strong>天然具备线程安全的特性</strong>，无需额外同步措施</li>\n<li>缓存哈希值：不可变性<strong>使得字符串的哈希值可以被缓存，提高相关数据结构的性能</strong>。</li>\n</ul>\n<p><strong>TIPS</strong></p>\n<p>可以用反射来改变 String 中 value 的值，所以严格意义上说不一定不可变。</p>\n<h2 id=\"13string-stringbuilder-stringbuffer-的区别\"><a class=\"anchor\" href=\"#13string-stringbuilder-stringbuffer-的区别\">#</a> 13.String、StringBuilder、StringBuffer 的区别？</h2>\n<ul>\n<li>\n<p>可变性:</p>\n<ul>\n<li>String 类是不可变类，一旦创建就无法改变其内容。对于每次修改操作 (例如拼接字符串)，都会创建一个新的字符串对象，旧对象则成为垃圾数据，需要等待垃圾回收。它们可以直接在原始对象上进行修改而不创建新的对象</li>\n<li>StringBuilder 和 StringBuffer 类是可变的，这种特性使得在频繁拼接或修改字符串时更高效。</li>\n</ul>\n</li>\n<li>\n<p>线程安全性:</p>\n<ul>\n<li>String 类是线程安全的，因为它的不可变性保证了多个线程同时访问同一个字符串对象时的安全性</li>\n<li><strong>StringBuilder 类是非线程安全的</strong>，它的方法没有进行同步处理。如果在多线程环境下使用 StringBuilder，需要额外来取措施保证线程安全</li>\n<li>StringBuffer 类是线程安全的，它的方法进行了同步处理，因此可以在多线程环境下使用</li>\n</ul>\n</li>\n<li>\n<p>性能:</p>\n<ul>\n<li>在单线程环境下，StringBuilder 的性能通常优于 StringBuffer，因为 StringBuilder 不进行同步处理，省去了同步的开销</li>\n<li>在多线程环境下，由于 StringBuffer 进行了同步处理，可能会带来额外的性能开销。但当线程同步是必需的时候，StringBuffer 是一个可靠的选择。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"image-20240714131415731.png\" alt=\"image-20240714131415731\" /></p>\n<h2 id=\"14-string-str-i与-string-str-new-stringi-一样吗\"><a class=\"anchor\" href=\"#14-string-str-i与-string-str-new-stringi-一样吗\">#</a> 14. String str = &quot;i&quot; 与 String str = new String (&quot;i&quot;) 一样吗？</h2>\n<p>不一样，因为内存的分配方式不一样。</p>\n<ul>\n<li>String str=&quot;i&quot; 的方式 JVM 会将其分配到<strong>常量池</strong>中；</li>\n<li>String str=new String (“i”) 方式，则会被分到<strong>堆内存</strong>中。</li>\n</ul>\n<h2 id=\"15-接口和抽象类有什么区别\"><a class=\"anchor\" href=\"#15-接口和抽象类有什么区别\">#</a> 15. 接口和抽象类有什么区别</h2>\n<ul>\n<li>\n<p>定义关键字不同</p>\n<ul>\n<li>接口使用关键字<strong> interface</strong> 来定义。抽象类使用关键字<strong> abstract</strong> 来定义</li>\n</ul>\n</li>\n<li>\n<p>继承或实现的关键字不同</p>\n<ul>\n<li>接口使用<strong> implements</strong> 关键字定义其具体实现。 抽象类使用 **extends ** 关键字实现继承</li>\n</ul>\n</li>\n<li>\n<p>子类扩展的数量不同</p>\n<ul>\n<li>接口的实现类可以有多个</li>\n<li>抽象类的子类，只能继承一个抽象类，抽象类的子类，只能继承一个抽象类</li>\n</ul>\n</li>\n<li>\n<p>属性访问控制符不同，方法控制符不同</p>\n<ul>\n<li>接口中属性的访问控制符只能是 public (接口中的属性默认是 public static final 修饰的)</li>\n<li>抽象类中的属性访问控制符无限制，可为任意控制符</li>\n</ul>\n</li>\n<li>\n<p>tip：</p>\n<ul>\n<li>接口可<strong>继承</strong>多个父接口</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"16-什么是浅拷贝和深拷贝\"><a class=\"anchor\" href=\"#16-什么是浅拷贝和深拷贝\">#</a> 16. 什么是浅拷贝和深拷贝？</h2>\n<ul>\n<li>浅拷贝: <strong>只复制指向某个对象的指针</strong>，而不复制对象本身，新旧对象共享一块内存</li>\n<li>深拷贝: <strong>复制并创建一个一摸一样的对象</strong>，不共享内存，修改新对象，旧对象保持不变</li>\n</ul>\n<p><img data-src=\"image-20240714132445512.png\" alt=\"image-20240714132445512\" /></p>\n<h2 id=\"17-overload-override-overwrite的区别\"><a class=\"anchor\" href=\"#17-overload-override-overwrite的区别\">#</a> 17. Overload、Override、Overwrite 的区别？</h2>\n<p>在面向对象编程中，有三个概念经常用到: Overload (重载)、Override (重写) 和 Overwrite (覆盖), 这些概念描述了不同的方法或函数之间的关系。</p>\n<p><strong>重载 (Overload) :</strong></p>\n<p>定义：在同一个类中，可以定义多个具有相同名称但参数列表不同的方法，它们被称为方法的重载</p>\n<p>特点:</p>\n<ul>\n<li><strong>方法名相同</strong>，参数列表不同</li>\n<li>重载方法可以有不同的返回类型</li>\n<li>重载方法必须在同一个类中</li>\n<li>重载方法的<strong>区分依据是参数</strong>的个数、类型或者顺序</li>\n</ul>\n<p><img data-src=\"image-20240714133843845.png\" alt=\"image-20240714133843845\" /></p>\n<p><strong>重写 (Override)</strong></p>\n<p>定义：子类继承自父类时，可以对父类的方法进行重新实现，这被称为方法的重写</p>\n<p>特点:</p>\n<ul>\n<li>子类中的方法与父类中的方法具有相同的名称、参数列表和返回类型</li>\n<li><strong>子类中的方法不能比父类的方法访问性更严格</strong></li>\n<li><strong>子类方法抛出的异常不能比父类方法抛出的异常更多</strong></li>\n<li>子类方法可以覆盖父类方法的实现，提供自己的实现逻辑</li>\n</ul>\n<p><img data-src=\"image-20240714133829892.png\" alt=\"image-20240714133829892\" /></p>\n<p><strong>覆盖 (Overwrite)</strong></p>\n<p>定义：在文件操作中，覆盖 (Overwrite) 通常指的是<strong>将已有的文件内容替换为新的内容</strong></p>\n<p>特点:</p>\n<ul>\n<li>覆盖通常发生在文件写入时，用新的内容覆盖原有的内容，使其被替代</li>\n<li>覆盖可能会导致原文件的内容丢失，因此在进行覆盖操作时要小心。</li>\n</ul>\n<h2 id=\"18-exception和error有什么区别\"><a class=\"anchor\" href=\"#18-exception和error有什么区别\">#</a> 18. Exception 和 Error 有什么区别？</h2>\n<p>在 Java 中，Exception 和 Error 是两个不同的类，它们<strong>都继承自 Throwable 类</strong>。下面是它们之间的区别:</p>\n<p><strong>Exception (异常) :</strong></p>\n<p>Exception 表示在程序执行过程中可能出现的可处理的异常情况。** 它一般由代码逻辑错误、外部条件变化等原因引起，可以通过适当的处理措施来恢复正常的程序执行。**Exception 分为两种类型:</p>\n<ul>\n<li><strong>受检异常 (Checked Exception)</strong> : 编译器要求必须在代码中显式地处理受检异常，否则代码无法通过编译。常见的受检异常包括 IOException、SQLException 等。（用 try-catch-finally）</li>\n<li><strong>非受检异常 (Unchecked Exception)</strong> : 编译器对非受检异常不强制要求进行处理，但可以选择处理或者将其抛给上层调用者处理。常见的非受检异常包括 NullPointerException、ArrayIndexOutOfBoundsException 等</li>\n</ul>\n<p><strong>Error (错误)：</strong></p>\n<p>Error 是<strong>指应用程序通常无法处理或恢复的严重问题</strong>，如除零错误</p>\n<p>Error 通常表示<strong>虚拟机 (JVM) 的错误状态或系统级错误</strong>，例如 OutOfMemoryError、StackOverflowError 等</p>\n<p>Error 通常意味着应用程序处于不可恢复的状态，因此一般不被捕获和处理</p>\n<p>与异常不同，Error 没有规定要求应用程序处理或捕获它们。</p>\n<h2 id=\"19-java中的io流的分类-说出几个你熟悉的实现类\"><a class=\"anchor\" href=\"#19-java中的io流的分类-说出几个你熟悉的实现类\">#</a> 19. Java 中的 IO 流的分类？说出几个你熟悉的实现类？</h2>\n<p>在 Java 中，10 流可以根据其功能和作用进行分类。主要分为四种类型：字节流、字符流、缓冲流和对象流</p>\n<p><img data-src=\"image-20240714134749700.png\" alt=\"image-20240714134749700\" /></p>\n<p><strong>字节流 (Byte Stream):</strong> <strong>以字节为单位进行读写操作的流</strong>。字节流通常用于处理二进制数据或字节流形式的文本数据。</p>\n<ul>\n<li>InputStream: 字节输入流的抽象基类，是所有字节输入流的超类</li>\n<li>OutputStream: 字节输出流的抽象基类，是所有字节输出流的超类</li>\n<li>一些实现类包括: FilelnputStream、FileOutputStream、ByteArraylnputStream、ByteArrayOutputStream 等</li>\n</ul>\n<p><strong>字符流 (Character Stream):</strong> <strong>以字符为单位进行读写操作的流</strong>。字符流通常用于处理字符数据，支持 Unicode 编码。</p>\n<ul>\n<li>Reader: 字符输入流的抽象基类，是所有字符输入流的超类</li>\n<li>Writer: 字符输出流的抽象基类，是所有字符输出流的超类</li>\n<li>一些实现类包括: FileReader、FileWriter、BufferedReader、PrintWriter 等</li>\n</ul>\n<p><strong>缓冲流 (Buffered Stream)</strong> : 提供了<strong>缓冲功能</strong>，可以减少实际 IO 操作的次数，提高读写效率</p>\n<ul>\n<li>BufferedInputStream: 字节缓冲输入流，装饰器模式实现</li>\n<li>BufferedOutputStream: 字节缓冲输出流，装饰器模式实现</li>\n<li>BufferedReader: 字符缓冲输入流，装饰器模式实现</li>\n<li>BufferedWriter: 字符缓冲输出流，装饰器模式实现</li>\n</ul>\n<p><strong>对象流 (Object Stream)</strong>:  <strong>用于读写 Java 对象的流</strong>。可以方便地将对象序列化和反序列化到文件或网络中</p>\n<ul>\n<li>ObjectlnputStream: 对象输入流，用于从流中读取对象</li>\n<li>ObjectOutputStream: 对象输出流，用于将对象写入流</li>\n</ul>\n<h2 id=\"20-常见的异常类有哪些\"><a class=\"anchor\" href=\"#20-常见的异常类有哪些\">#</a> 20. 常见的异常类有哪些？</h2>\n<p>RuntimeException (运行时异常)</p>\n<ul>\n<li>NullPointerException: 空指针异常，当对一个对象引用调用方法或访问属性时，对象引用为空</li>\n<li>ArraylndexOutOfBoundsException: 数组下标越界异常，当尝试访问数组的不存在的索引时抛出</li>\n<li>lllegalArgumentException: 非法参数异常，当传递给方法的参数不合法时抛出</li>\n<li>lllegalStateException: 非法状态异常，当对象处于不允许的状态下调用方法时抛出</li>\n</ul>\n<p>IOException (输入输出异常) :</p>\n<ul>\n<li>FileNotFoundException: 文件未找到异常，当尝试打开不存在的文件时抛出</li>\n<li>EOFException: 文件结束异常，当从数据流读取数据时到达文件末尾时抛出</li>\n<li>SocketException: 套接字异常，当与套接字相关的操作失败时抛出</li>\n</ul>\n<p>SQLException (数据库异常) :</p>\n<ul>\n<li>SQLSyntaxErrorException: SQL 语法错误异常，当执行 SQL 语句时遇到语法错误时抛出</li>\n<li>DataAccessException: 数据访问异常，当访问数据库或数据存储出现问题时抛出</li>\n</ul>\n<p>ClassNotFoundException: 类未找到异常，当尝试加载不存在的类时抛出</p>\n<h2 id=\"21-applicationcontext和beanfactory有什么区别\"><a class=\"anchor\" href=\"#21-applicationcontext和beanfactory有什么区别\">#</a> 21. ApplicationContext 和 BeanFactory 有什么区别</h2>\n<p>BeanFactory 是 Spring 中非常核心的组件，表示 Bean 工厂，可以生成 bean，维护 bean，</p>\n<p>而 ApplicationContxt 继承了 Beanfactory，所以具有 BeanFactory 的特点。</p>\n<p>ApplicationContext 除了继承 BeanFactory 之外，还继承了诸如 EnvironmentCapable、MessageSource、ApplicationEventPublisher 等接口，从而 ApplicationContext 还有获取系统环境变量、国际化、事件发布等功能，这是 BeanFactory 不具备的。</p>\n<h2 id=\"22-arraylist和linkedlist区别\"><a class=\"anchor\" href=\"#22-arraylist和linkedlist区别\">#</a> 22. ArrayList 和 LinkedList 区别</h2>\n<ul>\n<li>底层数据结构不同，ArrayList 底层是基于数组实现的，LinkedList 底层是基于链表实现的</li>\n<li>由于底层数据结构不同，他们所适用的场景也不同，ArrayList 更适合随机查找，Linkedlist 更适合删除和添加，查询、添加、删除的时间复杂度不同</li>\n<li>另外 Arravlist 和 LinkedList 都实现了 List 接口，但是 LinkedList 还额外实现了 Deque 接口，所以 LinkedlList 还可以当做队列来使用</li>\n</ul>\n<h2 id=\"23-b树和b树的区别为什么mysql使用b树\"><a class=\"anchor\" href=\"#23-b树和b树的区别为什么mysql使用b树\">#</a> 23. B 树和 B + 树的区别，为什么 Mysql 使用 B + 树</h2>\n<p><strong>B 树的特点</strong></p>\n<ul>\n<li>节点排序</li>\n<li>一个节点可以存多个元素，多个元素也排序了</li>\n</ul>\n<p><strong>B + 树的特点</strong></p>\n<ul>\n<li>拥有 B 例的特点</li>\n<li>子节点之间有指钊</li>\n<li>非叶子节点上的元素仙叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序</li>\n</ul>\n<p>Mysq 索引使用的是 B+，因为索引是用来加快查询的，而 B + 树通过对数据排序所以是可以提高查询速度的</p>\n<p>然后通过一个节点中可以有储多个元素，从而可以使得 B + 树的高度不会太高，在 Mysql 中一个 Innodb 页就是一个 B + 树节点，一 Innodb 页默认 16kb，所以一般情况下一颗两层的 B + 可以存 2000 万行左右的数</p>\n<p>然后通过利用 B + 树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，以微了的支持全表描，范围查找等 SQL 语句</p>\n<h2 id=\"24-copyonwritearraylist的底层原理是怎样的\"><a class=\"anchor\" href=\"#24-copyonwritearraylist的底层原理是怎样的\">#</a> 24. CopyOnWriteArrayList 的底层原理是怎样的</h2>\n<ul>\n<li>首先 CopyOnWriteArrayList 内也是用时数组来实现的，在向 CopyOnWriteArrayList 添元索时，会复制一个新的数组，<strong>写操作在新数进行，读操作在原数组上进行</strong></li>\n<li>并且，<strong>写操作会加锁</strong>，防止出现并发写入丢失数据的问题</li>\n<li><strong>写操作结束之后会把原数组指向新数组</strong></li>\n<li>CopyOnWiteArraylist<strong> 允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场</strong>，但是 CopyOnWiteAraylist 会比较占内存，同时可能读到的数据不是实时最新的数据，所以不<strong>适合实时性要求很高的场景</strong></li>\n</ul>\n<p>……</p>\n<h2 id=\"30-hashmap的扩容机制原理\"><a class=\"anchor\" href=\"#30-hashmap的扩容机制原理\">#</a> 30. HashMap 的扩容机制原理</h2>\n<p><strong>1.7 版本</strong></p>\n<ol>\n<li>先生成新数组</li>\n<li>遍历老数组中的每个位置上的链表上的每个元素</li>\n<li>取每个元素的 key，并基于新数组长度，计算出每个元素在新数组中的下标</li>\n<li>将元素添加到新数组中去</li>\n<li>所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性</li>\n</ol>\n<p><strong>1.8 版本</strong></p>\n<ol>\n<li>先生成新数组</li>\n<li>遍历老数组中的每个位置上的链表或红黑树</li>\n<li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</li>\n<li>如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置\n<ol>\n<li>统计每个下标位置的元素个数</li>\n<li>如果该位置下的元素个数超过了 8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置</li>\n<li>如果该位置下的元素个数没有超过 8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置</li>\n</ol>\n</li>\n<li>所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性</li>\n</ol>\n<p>Tips:</p>\n<p>1.7 版本的 hash 链表的部分是头插法，不需要遍历到尾部，更快</p>\n<p>1.8 版本的 hash 链表的部分是尾插法，因为要判断是否大于 8，大于 8 就转换成红黑树，而知道数量需要遍历链表，则用尾插法</p>\n<h2 id=\"32-java死锁如何避免\"><a class=\"anchor\" href=\"#32-java死锁如何避免\">#</a> 32. Java 死锁如何避免</h2>\n<p><strong>造成死锁的几个原因</strong></p>\n<ul>\n<li>一个资源每次只能被一个线程使用</li>\n<li>一个线程在阻塞等待某个资源时，不释放已占有资源</li>\n<li>一个线程已经获得的资源，在未使用完之前，不能被强行剥夺</li>\n<li>若干线程形成头尾相接的循环等待资源关系</li>\n</ul>\n<p>这是造成死锁必须要达到的 4 个条件，如果要避免死锁，只需要不满足其中某一个条件即可。</p>\n<p>而其中前 3 个条件是作为锁要符合的条件，所以要避免死执就需要打破第 4 个条件，不出现循环等待锁的关系</p>\n<p>在开发过程中:</p>\n<ul>\n<li>要注意<strong>加锁顺序</strong>，保证每个线程按同样的顺序进行加锁</li>\n<li>要注意加锁时限，可以针对所设置一个<strong>超时时间</strong></li>\n<li>要注意<strong>死锁检查</strong>，这是一种预防机制，确保在第一时间发现死锁并进行解决</li>\n</ul>\n<h2 id=\"34-java中有哪些类加载器\"><a class=\"anchor\" href=\"#34-java中有哪些类加载器\">#</a> 34. Java 中有哪些类加载器</h2>\n<p>JDK 自带有三个类加载器: bootstrap ClassLoader、ExtClassLoader、AppClassLoader。</p>\n<ul>\n<li>BootStrapClassLoader 是 ExtClassLoader 的父类加载器，默认负责加载 % JAVA HOME% lib 下的 iar 包和 cass 文件</li>\n<li>ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载 % JAVA HOME%/lib/ext 文件夹下的 jar 包和 class 类</li>\n<li>AppClassLoader 是自定义类加载器的父类，负责加载 lasspath 下的类文件</li>\n</ul>\n<h2 id=\"38-mybatis的优缺点\"><a class=\"anchor\" href=\"#38-mybatis的优缺点\">#</a> 38. Mybatis 的优缺点</h2>\n<p><strong>优点:</strong></p>\n<ul>\n<li>基于 SOL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>\n<li>与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量几余的代码，不需要手动开关连接；</li>\n<li>很好的与各种数据库兼容 (因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持)</li>\n<li>能够与 Spring 很好的集成</li>\n<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射，提供对象关系映射标签，支持对象关系组件维护</li>\n</ul>\n<p><strong>缺点:</strong></p>\n<ul>\n<li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求</li>\n<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>\n</ul>\n<h2 id=\"39-和的区别是什么\"><a class=\"anchor\" href=\"#39-和的区别是什么\">#</a> 39. #{} 和 ${} 的区别是什么？</h2>\n<p>#{} 是预编译处理、是占位符，${} 是字符串替换、是拼接符。</p>\n<p>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为？号，调用 PreparedStatement 来赋值</p>\n<p>Mybatis 在处理<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow></mrow><mtext>时，会将</mtext><mi>s</mi><mi>q</mi><mi>l</mi><mtext>中的</mtext></mrow><annotation encoding=\"application/x-tex\">{}时，会将sql中的</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">会</span><span class=\"mord cjk_fallback\">将</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">的</span></span></span></span> {} 替换成变量的值，调用 Statement 来赋值</p>\n<p>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性</p>\n<h2 id=\"40-mysql慢查询该如何优化\"><a class=\"anchor\" href=\"#40-mysql慢查询该如何优化\">#</a> 40. Mysql 慢查询该如何优化？</h2>\n<ul>\n<li>检查是否走了索引，如果没有则优化 SQL 利用索引</li>\n<li>检查所利用的索引，是否是最优索引</li>\n<li>检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据检查表中数据是否过多，是否应该进行分库分表了</li>\n<li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源</li>\n</ul>\n<h2 id=\"41-mysql锁有哪些如何理解\"><a class=\"anchor\" href=\"#41-mysql锁有哪些如何理解\">#</a> 41. Mysql 锁有哪些，如何理解</h2>\n<ul>\n<li>按锁粒度分类\n<ul>\n<li>行锁：锁某行数据，锁粒度最小，并发度高</li>\n<li>表锁：锁整张表，锁粒度最大，并发度低</li>\n<li>间隙锁：锁的是一个区间</li>\n</ul>\n</li>\n<li>读写分类\n<ul>\n<li>共享锁：也就是读锁。一个事务给某行数据加了读锁，其他事务也可以读，但是不能写</li>\n<li>排它锁：也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写</li>\n</ul>\n</li>\n<li>还可以分为\n<ul>\n<li>乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的</li>\n<li>悲观锁：上面所的行锁、表锁等都是悲观锁</li>\n</ul>\n</li>\n<li>在事务的隔离级别实现中，就需要利用锁来解决幻读</li>\n</ul>\n<h2 id=\"42-redis和mysql如何保证数据一致\"><a class=\"anchor\" href=\"#42-redis和mysql如何保证数据一致\">#</a> 42. Redis 和 Mysql 如何保证数据一致</h2>\n<ul>\n<li><strong>先更新 Mysql，再更新 Redis</strong>，如果更新 Redis 失败，可能仍然不一致</li>\n<li><strong>先删除 Redis 存数据，再更新 Mysql</strong>，再次查询的时候在将数据添加到存中，这种方案能解决 1 方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程 1 删除了 Redis 缓存数据，正在更新 Mysql，此时另外一个查询再查询，那么就会把 Mysql 中老数据又查到 Redis 中</li>\n<li><strong>延时双删</strong>，步骤是：先删除 Redis 存数据，再更新 Mysql，延几百毫秒再删除 Redis 存数据，这样就算在更新 Mysql 时，有其他线程读了 Mysql，把老教据读到了 Redis 中，那么也会被删除掉，从而把数据保持一致</li>\n</ul>\n<h2 id=\"43-redis有哪些数据结构-分别有哪些典型的应用场景\"><a class=\"anchor\" href=\"#43-redis有哪些数据结构-分别有哪些典型的应用场景\">#</a> 43. Redis 有哪些数据结构？分别有哪些典型的应用场景？</h2>\n<p>Redis 的数据结构有:</p>\n<ul>\n<li><strong>字符串 string</strong>: 可以用来做最简单的数，可以存某个简单的字符串，也可以存某个 json 格式的字符审，Redis 分布式锁的实现就利用了这种数结构，还包括可以实现计数器、Session 共享、分布式 ID</li>\n<li><strong>哈希表 hash</strong>: 可以用来存储一些 key-value 对，更适合用来存储对象</li>\n<li><strong>列表 list</strong>: Redis 的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li>\n<li><strong>集合 set</strong>: 和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能</li>\n<li><strong>有序集合 zset</strong>: 集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</li>\n</ul>\n<h6 id=\"\"><a class=\"anchor\" href=\"#\">#</a> ……</h6>\n<h2 id=\"48-spring-boot是如何启动tomcat的\"><a class=\"anchor\" href=\"#48-spring-boot是如何启动tomcat的\">#</a> 48. Spring Boot 是如何启动 Tomcat 的</h2>\n<ol>\n<li>首先，SpringBoot 在启动时会先创建一个 Spring 容器</li>\n<li>在创建 Spring 容器时程中，会 @ConditionalOnClass 技术来判新当前 classpath 中是否存在 Tomcat 依赖，如果存在会生成一个启动 Tomcat 的 Bean</li>\n<li>Spring 容器创建完之后，就会获取启动 Tomcat 的 Bean，并创建 Tomcat 对象，并绑定端口等，然后启动 Tomcat</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        }
    ]
}