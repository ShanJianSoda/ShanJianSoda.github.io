{
    "version": "https://jsonfeed.org/version/1",
    "title": "Chen • All posts by \"设计模式\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/04/16/About-ep-workflow/",
            "url": "http://example.com/2025/04/16/About-ep-workflow/",
            "title": "About ep-workflow",
            "date_published": "2025-04-16T03:30:13.000Z",
            "content_html": "<h1 id=\"项目概述\"><a class=\"anchor\" href=\"#项目概述\">#</a> 项目概述</h1>\n<p>这是一个基于 Flowable 的工作流项目，名为 epkeeper-workflow</p>\n<p>项目采用 Maven 多模块结构，包含两个主要模块：</p>\n<ul>\n<li>epkeeper-workflow-api：API 接口模块</li>\n<li>epkeeper-workflow-provider：服务提供者模块</li>\n</ul>\n<h2 id=\"技术栈\"><a class=\"anchor\" href=\"#技术栈\">#</a> 技术栈</h2>\n<ul>\n<li>\n<p>核心工作流引擎：Flowable</p>\n</li>\n<li>\n<p>数据库：MySQL</p>\n</li>\n<li>\n<p>缓存：Redis</p>\n</li>\n<li>\n<p>服务发现：Nacos</p>\n</li>\n<li>\n<p>消息队列：RabbitMQ</p>\n</li>\n<li>\n<p>ORM：MyBatis</p>\n</li>\n</ul>\n<h2 id=\"项目结构\"><a class=\"anchor\" href=\"#项目结构\">#</a> 项目结构</h2>\n<p>epkeeper-workflow-api 模块：</p>\n<ul>\n<li>\n<p>包含核心领域模型（core）</p>\n</li>\n<li>\n<p>Dubbo 接口定义</p>\n</li>\n<li>\n<p>数据模型和 POJO 对象</p>\n</li>\n</ul>\n<p>epkeeper-workflow-provider 模块：</p>\n<ul>\n<li>控制器层（Controller）</li>\n<li>Flowable 相关配置和处理器</li>\n<li>服务实现层</li>\n<li>MyBatis 数据访问层</li>\n</ul>\n<h2 id=\"主要功能\"><a class=\"anchor\" href=\"#主要功能\">#</a> 主要功能</h2>\n<ul>\n<li>\n<p>工作流程管理</p>\n</li>\n<li>\n<p>任务处理</p>\n</li>\n<li>\n<p>流程定义和部署</p>\n</li>\n<li>\n<p>表单管理</p>\n</li>\n<li>\n<p>用户任务管理（发起、待办、已办、抄送等）</p>\n</li>\n</ul>\n<h2 id=\"示例功能\"><a class=\"anchor\" href=\"#示例功能\">#</a> 示例功能</h2>\n<ul>\n<li>\n<p>包含一个完整的请假流程示例</p>\n</li>\n<li>\n<p>展示了从流程设计到实现的完整流程</p>\n</li>\n<li>\n<p>包含表单设计、流程定义、任务处理等功能</p>\n</li>\n</ul>\n<h2 id=\"特色功能\"><a class=\"anchor\" href=\"#特色功能\">#</a> 特色功能</h2>\n<ul>\n<li>\n<p>支持流程变量管理</p>\n</li>\n<li>\n<p>提供任务状态管理</p>\n</li>\n<li>\n<p>支持流程监听和超时处理</p>\n</li>\n<li>\n<p>提供自定义命令扩展</p>\n</li>\n<li>\n<p>支持业务表与工作流的绑定</p>\n</li>\n</ul>\n<h1 id=\"项目中用到的设计模式\"><a class=\"anchor\" href=\"#项目中用到的设计模式\">#</a> 项目中用到的设计模式</h1>\n<ul>\n<li>\n<p>工厂模式（Factory Pattern）</p>\n<ul>\n<li>\n<p>在 QueryUtils 类中使用了工厂模式创建各种查询对象</p>\n</li>\n<li>\n<p>例如：modelQuery ()、definitionQuery ()、deploymentQuery () 等方法都是工厂方法的实现</p>\n</li>\n<li>\n<p>这些方法封装了对象的创建过程，提供了统一的接口</p>\n</li>\n</ul>\n</li>\n<li>\n<p>单例模式（Singleton Pattern）</p>\n<ul>\n<li>\n<p>在 QueryUtils 类中使用了单例模式</p>\n</li>\n<li>\n<p>通过 private static final 确保 PROCESS_ENGINE 只有一个实例</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&lt;img src=&quot;image-20250416120059550.png&quot; alt=&quot;image-20250416120059550&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>\n<p>观察者模式（Observer Pattern）</p>\n<ul>\n<li>\n<p>在 GlobalFlowableListener 类中实现了 FlowableEventListener 接口</p>\n</li>\n<li>\n<p>用于监听工作流引擎的各种事件，如任务创建、任务到期等</p>\n</li>\n<li>\n<p>通过 onEvent 方法响应不同类型的事件</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&lt;img src=&quot;image-20250416121122134.png&quot; alt=&quot;image-20250416121122134&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>\n<p>策略模式（Strategy Pattern）</p>\n<ul>\n<li>\n<p>在 FlowableConfig 类中通过配置不同的处理器来实现不同的策略</p>\n</li>\n<li>\n<p>例如：自定义的 ID 生成器、事件监听器、任务处理器等</p>\n</li>\n<li>\n<p>这些都可以通过配置来灵活切换不同的实现策略</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&lt;img src=&quot;image-20250416121209328.png&quot; alt=&quot;image-20250416121209328&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>\n<p>模板方法模式（Template Method Pattern）</p>\n<ul>\n<li>\n<p>在 BaseEntity 类中定义了通用的实体类属性和方法</p>\n</li>\n<li>\n<p>子类可以继承这个基类，复用通用的字段和行为</p>\n</li>\n<li>\n<p>包含了创建时间、更新时间等通用字段的自动填充逻辑</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&lt;img src=&quot;image-20250416121303749.png&quot; alt=&quot;image-20250416121303749&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>\n<p>建造者模式（Builder Pattern）</p>\n<ul>\n<li>\n<p>在 PageQuery 类中使用了建造者模式</p>\n</li>\n<li>\n<p>通过 build () 方法构建分页对象</p>\n</li>\n<li>\n<p>支持链式调用设置各种参数</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&lt;img src=&quot;image-20250416121826481.png&quot; alt=&quot;image-20250416121826481&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>\n<p>命令模式（Command Pattern）</p>\n<ul>\n<li>\n<p>在工作流处理中使用了命令模式</p>\n</li>\n<li>\n<p>通过 TaskTimeoutJobHandler 等处理器封装了具体的任务处理逻辑</p>\n</li>\n<li>\n<p>将请求封装为对象，使得可以用不同的请求对客户进行参数化</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&lt;img src=&quot;image-20250416121543926.png&quot; alt=&quot;image-20250416121543926&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n",
            "tags": [
                "workflow",
                "项目整理",
                "设计模式"
            ]
        },
        {
            "id": "http://example.com/2023/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01/",
            "url": "http://example.com/2023/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01/",
            "title": "设计模式01",
            "date_published": "2023-10-23T07:03:19.000Z",
            "content_html": "<p>跟着该视频做的一个笔记<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUc0NDExYzdONA==\">尚硅谷 Java 设计模式（图解 + 框架源码剖析）</span></p>\n<h1 id=\"设计模式\"><a class=\"anchor\" href=\"#设计模式\">#</a> 设计模式</h1>\n<h2 id=\"1设计模式的目的\"><a class=\"anchor\" href=\"#1设计模式的目的\">#</a> 1 设计模式的目的</h2>\n<p>编写软件过程中，程序员面临着来自<strong>耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性</strong>等多方面的挑战，设计模式是为了让程序 (软件)，具有更好的</p>\n<ul>\n<li>代码重用性 (即：相同功能的代码，不用多次编写)</li>\n<li>可读性 (即：编程规范性，便于其他程序员的阅读和理解)</li>\n<li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>\n<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>\n</ul>\n<p>使程序呈现<strong>高内聚，低耦合</strong>的特性</p>\n<h2 id=\"2设计模式七大原则\"><a class=\"anchor\" href=\"#2设计模式七大原则\">#</a> 2 设计模式七大原则</h2>\n<p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础 (即：设计模式为什么这样设计的依据)</p>\n<p>设计模式常用的七大原则有:</p>\n<h3 id=\"21-单一职责原则single-responsibility-principle\"><a class=\"anchor\" href=\"#21-单一职责原则single-responsibility-principle\">#</a> 2.1 单一职责原则（Single Responsibility Principle）</h3>\n<ul>\n<li>降低类的复杂度，一个类只负责一项职责</li>\n<li>提高类的可读性，可维护性，降低变更引起的风险</li>\n<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>\n</ul>\n<p>对类来说的，即一个类应该只负责<strong>一项职责</strong>。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p>\n<h3 id=\"22接口隔离原则interface-segregation-principle\"><a class=\"anchor\" href=\"#22接口隔离原则interface-segregation-principle\">#</a> 2.2 接口隔离原则（Interface Segregation Principle）</h3>\n<p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p>\n<p>也就是说接口要细拆分，类只需要实现相关的接口，不需要实现用不到的</p>\n<h3 id=\"23依赖倒转倒置原则dependence-inversion-principle\"><a class=\"anchor\" href=\"#23依赖倒转倒置原则dependence-inversion-principle\">#</a> 2.3 依赖倒转 (倒置) 原则（Dependence Inversion Principle）</h3>\n<ul>\n<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>\n<li>抽象不应该依赖细节，细节应该依赖抽象</li>\n<li>依赖倒转 (倒置) 的中心思想是面向接口编程</li>\n<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li>\n<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>\n</ul>\n<p>依赖倒转原则的注意事项和细节</p>\n<ul>\n<li><strong>低层模块尽量都要有抽象类或接口</strong>，或者两者都有，程序稳定性更好，最好不要一个类孤零零的</li>\n<li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个<strong>缓冲层</strong>，利于程序扩展和优化</li>\n<li>继承时遵循里氏替换原则</li>\n</ul>\n<h3 id=\"24里氏替换原则liskov-substitution-principle\"><a class=\"anchor\" href=\"#24里氏替换原则liskov-substitution-principle\">#</a> 2.4 里氏替换原则（Liskov Substitution Principle）</h3>\n<blockquote>\n<p>OO 中的继承性的思考和说明：</p>\n<p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</p>\n<p>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</p>\n<p>问题提出：在编程中，<strong>如何正确的使用继承</strong>？=&gt; 里氏替换原则</p>\n</blockquote>\n<p>在使用继承时，遵循里氏替换原则，在<strong>子类中尽量不要重写父类的方法</strong></p>\n<p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p>\n<h3 id=\"25开闭原则open-closed-principle\"><a class=\"anchor\" href=\"#25开闭原则open-closed-principle\">#</a> 2.5 开闭原则 (Open Closed Principle)</h3>\n<p>开闭原则是编程中<em><strong>最基础、最重要</strong></em>的设计原则</p>\n<p>一个软件实体如类、模块和函数应该对扩展开放 (对提供方)，对修改关闭 (对使用方)。用抽象构建框架，用实扩展细节。</p>\n<p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</p>\n<h3 id=\"26迪米特法则demeter-principle\"><a class=\"anchor\" href=\"#26迪米特法则demeter-principle\">#</a> 2.6 迪米特法则（Demeter Principle）</h3>\n<p>迪米特法则的核心是降低类之间的耦合。由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间 (对象间) 耦合关系， 并不是要求完全没有依赖关系</p>\n<p>迪米特法则又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信</p>\n<p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>\n<h3 id=\"27合成复用原则composite-reuse-principle\"><a class=\"anchor\" href=\"#27合成复用原则composite-reuse-principle\">#</a> 2.7 合成复用原则 (Composite Reuse Principle)</h3>\n<p>原则是尽量使用合成 / 聚合的方式，而不是使用继承</p>\n<p><img data-src=\"image-20240301154812906.png\" alt=\"\" /></p>\n<h3 id=\"28设计模式的原则核心\"><a class=\"anchor\" href=\"#28设计模式的原则核心\">#</a> 2.8 设计模式的原则核心</h3>\n<p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>\n<p>针对接口编程，而不是针对实现编程。</p>\n<p>为了交互对象之间的松耦合设计而努力。</p>\n<h2 id=\"3uml类图\"><a class=\"anchor\" href=\"#3uml类图\">#</a> 3.UML 类图</h2>\n<h3 id=\"31基本介绍\"><a class=\"anchor\" href=\"#31基本介绍\">#</a> 3.1 基本介绍</h3>\n<p><img data-src=\"image-20240301155116451.png\" alt=\"image-20240301155116451\" /></p>\n<h3 id=\"32类图分类\"><a class=\"anchor\" href=\"#32类图分类\">#</a> 3.2 类图分类</h3>\n<ol>\n<li>用例图（use case）</li>\n<li>静态结构图: <strong>类图</strong>、对象图、包图、组件图、部署图</li>\n<li>动态行为图：交互图 (时序图与协作图)、状态图、活动图</li>\n</ol>\n<h3 id=\"33类之间的关系\"><a class=\"anchor\" href=\"#33类之间的关系\">#</a> 3.3 类之间的关系</h3>\n<p>依赖、泛化（继承）、实现、关联、聚合、组合</p>\n<h4 id=\"依赖\"><a class=\"anchor\" href=\"#依赖\">#</a> 依赖</h4>\n<p>只要类中用到了对方，则构成依赖关系</p>\n<p>类成员属性、方法返回类型、方法参数接受的参数类型、方法中使用到</p>\n<h4 id=\"泛化继承\"><a class=\"anchor\" href=\"#泛化继承\">#</a> 泛化（继承）</h4>\n<p>继承，依赖关系的特例</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h4>\n<p>接口实现，依赖关系的特例</p>\n<h4 id=\"关联\"><a class=\"anchor\" href=\"#关联\">#</a> 关联</h4>\n<p>类与类之间的联系，依赖关系的特例</p>\n<h4 id=\"聚合\"><a class=\"anchor\" href=\"#聚合\">#</a> 聚合</h4>\n<p>表示整体和部分的关系，整体和部分能分开，关联关系特例（private A；）</p>\n<p>如果不能分开，则升级为组合关系（private A = new A（）；）</p>\n<h4 id=\"组合\"><a class=\"anchor\" href=\"#组合\">#</a> 组合</h4>\n<p>整体和部分不能分开</p>\n<h2 id=\"4设计模式概述\"><a class=\"anchor\" href=\"#4设计模式概述\">#</a> 4. 设计模式概述</h2>\n<p>设计模式分为三种类型，共 23 种（？）</p>\n<ol>\n<li><strong>创建型模式</strong>：&lt;u&gt; 单例模式 &lt;/u&gt;、抽象工厂模式、原型模式、建造者模式、&lt;u &gt; 工厂模式 &lt;/u&gt;</li>\n<li><strong>结构型模式</strong>：适配器模式、桥接模式、&lt;u&gt; 装饰模式 &lt;/u&gt;、组合模式、外观模式、享元模式、&lt;u &gt; 代理模式 &lt;/u&gt;</li>\n<li><strong>行为型模式</strong>：模版方法模式、命令模式、访问者模式、迭代器模式、&lt;u&gt; 观察者模式 &lt;/u&gt;、中介者模式、备忘录模式、解释器模式 (Interpreter 模式)、状态模式、策略模式、职责链模式 (责任链模式)</li>\n</ol>\n<h3 id=\"单例模式\"><a class=\"anchor\" href=\"#单例模式\">#</a> 单例模式</h3>\n<p>单例模式有八种方式</p>\n<h4 id=\"饿汉式静态常量\"><a class=\"anchor\" href=\"#饿汉式静态常量\">#</a> 饿汉式 (静态常量)</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 饿汉式（静态变量）</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 用之前就创建</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 构造器私有化，外部不能 new</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 本类内部创建对象实例</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 提供一个公有的静态方法，返回对象实例</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>避免了线程同步问题，但是没实现懒加载，<strong>可能</strong>会造成内存浪费</p>\n<h4 id=\"饿汉式静态代码块\"><a class=\"anchor\" href=\"#饿汉式静态代码块\">#</a> 饿汉式 (静态代码块)</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>……</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 静态代码块</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>……</pre></td></tr></table></figure><h4 id=\"懒汉式线程不安全\"><a class=\"anchor\" href=\"#懒汉式线程不安全\">#</a> 懒汉式 (线程不安全)</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton02</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 构造器私有化，外部不能 new</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton02</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 提供一个静态的公有方法，当使用到该方法时，才去创建</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 饿汉模式</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">//synchronized, 解决线程同步问题，但是效率低，后续获取都要进行同步</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">Singleton02</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"懒汉式线程安全同步方法\"><a class=\"anchor\" href=\"#懒汉式线程安全同步方法\">#</a> 懒汉式 (线程安全，同步方法)</h4>\n<pre><code>synchronized //效率低，不使用\n</code></pre>\n<h4 id=\"懒汉式线程安全同步代码块\"><a class=\"anchor\" href=\"#懒汉式线程安全同步代码块\">#</a> 懒汉式 (线程安全，同步代码块)</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">Singleton02</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token comment\">// 当多个现程进入后，即使一个个来，但是还是会选择创建，不使用</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Singleton02</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"双重检查\"><a class=\"anchor\" href=\"#双重检查\">#</a> 双重检查</h4>\n<pre><code>public static synchronized Singleton02 getInstance() &#123;\n        if (instance == null) &#123;\n            synchronized (Singleton02.class) &#123;\n                if (instance == null)\n                    instance = new Singleton02();\n            &#125;\n        &#125;\n        return instance;\n&#125;\n</code></pre>\n<h4 id=\"静态内部类\"><a class=\"anchor\" href=\"#静态内部类\">#</a> 静态内部类</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton03</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 构造器私有化，外部不能 new</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton03</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 当外部类被装载时，静态内部类并不会装载</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token comment\">// 当静态内部类装载时，是线程安全 (JVM 底层提供的机制)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonInstance</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Singleton03</span> singleton <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton03</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">Singleton02</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Singleton02</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"枚举\"><a class=\"anchor\" href=\"#枚举\">#</a> 枚举</h4>\n<p>借助 JDK1.5 中添加的枚举类实现，不仅避免多线程同步问题，而且防止反序列化重新创建新的对象</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Singleton04</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token constant\">INSTANCE</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 属性</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayLove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"heart~\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"单例模式注意事项和细节说明\"><a class=\"anchor\" href=\"#单例模式注意事项和细节说明\">#</a> 单例模式注意事项和细节说明</h4>\n<ol>\n<li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>\n<li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li>\n<li>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多 (即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象 (比如数据源、session 工厂等)</li>\n</ol>\n<h3 id=\"工厂设计模式\"><a class=\"anchor\" href=\"#工厂设计模式\">#</a> 工厂设计模式</h3>\n<h4 id=\"简单工厂\"><a class=\"anchor\" href=\"#简单工厂\">#</a> 简单工厂</h4>\n<h4 id=\"工厂方法\"><a class=\"anchor\" href=\"#工厂方法\">#</a> 工厂方法</h4>\n<h4 id=\"抽象工厂\"><a class=\"anchor\" href=\"#抽象工厂\">#</a> 抽象工厂</h4>\n",
            "tags": [
                "设计模式"
            ]
        }
    ]
}