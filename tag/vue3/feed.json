{
    "version": "https://jsonfeed.org/version/1",
    "title": "Chen • All posts by \"vue3\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/08/16/Learn-Vue3/",
            "url": "http://example.com/2024/08/16/Learn-Vue3/",
            "title": "Learn Vue3",
            "date_published": "2024-08-16T14:55:05.000Z",
            "content_html": "<p>摘自 https://cn.vuejs.org/guide/</p>\n<h1 id=\"模板语法\"><a class=\"anchor\" href=\"#模板语法\">#</a> 模板语法</h1>\n<h2 id=\"文本插值\"><a class=\"anchor\" href=\"#文本插值\">#</a> 文本插值</h2>\n<p>最基本的数据绑定形式是文本插值，它使用的是 “Mustache” 语法 (即双大括号)：</p>\n<p>template</p>\n<pre><code>&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;\n</code></pre>\n<p>双大括号标签会被替换为相应组件实例中  <code>msg</code>  属性的值。同时每次  <code>msg</code>  属性更改时它也会同步更新。</p>\n<h2 id=\"attribute-绑定\"><a class=\"anchor\" href=\"#attribute-绑定\">#</a> Attribute 绑定</h2>\n<p>双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用  <code>v-bind</code>  指令：</p>\n<p>template</p>\n<pre><code>&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p><code>v-bind</code>  指令指示 Vue 将元素的  <code>id</code>  attribute 与组件的  <code>dynamicId</code>  属性保持一致。如果绑定的值是  <code>null</code>  或者  <code>undefined</code> ，那么该 attribute 将会从渲染的元素上移除。</p>\n<p><strong>简写</strong></p>\n<pre><code>&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"动态绑定多个值\"><a class=\"anchor\" href=\"#动态绑定多个值\">#</a> 动态绑定多个值</h3>\n<p>如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：</p>\n<pre><code>const objectOfAttrs = &#123;\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n&#125;\n</code></pre>\n<p>通过不带参数的  <code>v-bind</code> ，你可以将它们绑定到单个元素上：</p>\n<p>template</p>\n<pre><code>&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h2 id=\"使用-javascript-表达式\"><a class=\"anchor\" href=\"#使用-javascript-表达式\">#</a> 使用 JavaScript 表达式</h2>\n<p>至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：</p>\n<p>template</p>\n<pre><code>&#123;&#123; number + 1 &#125;&#125;\n\n&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;\n\n&#123;&#123; message.split('').reverse().join('') &#125;&#125;\n\n&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。</p>\n<p>在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p>\n<ul>\n<li>在文本插值中 (双大括号)</li>\n<li>在任何 Vue 指令 (以  <code>v-</code>  开头的特殊 attribute) attribute 的值中</li>\n</ul>\n<h3 id=\"调用函数\"><a class=\"anchor\" href=\"#调用函数\">#</a> 调用函数</h3>\n<p>可以在绑定的表达式中使用一个组件暴露的方法：</p>\n<p>template</p>\n<pre><code>&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt;\n  &#123;&#123; formatDate(date) &#125;&#125;\n&lt;/time&gt;\n</code></pre>\n<p>TIP</p>\n<p>绑定在表达式中的方法在组件每次更新时都会被重新调用，因此<strong>不</strong>应该产生任何副作用，比如改变数据或触发异步操作。</p>\n<h2 id=\"指令-directives\"><a class=\"anchor\" href=\"#指令-directives\">#</a> 指令 Directives</h2>\n<p>指令是带有  <code>v-</code>  前缀的特殊 attribute。Vue 提供了许多内置指令</p>\n<p>指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的  <code>v-for</code> 、 <code>v-on</code>  和  <code>v-slot</code> )。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 <a href=\"https://cn.vuejs.org/api/built-in-directives.html#v-if\"> <code>v-if</code> </a> 为例：</p>\n<pre><code>&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;\n</code></pre>\n<p>这里， <code>v-if</code>  指令会基于表达式  <code>seen</code>  的值的真假来移除 / 插入该  <code>&lt;p&gt;</code>  元素。</p>\n<h3 id=\"参数-arguments\"><a class=\"anchor\" href=\"#参数-arguments\">#</a> 参数 Arguments</h3>\n<p>某些指令会需要一个 “参数”，在指令名后通过一个冒号隔开做标识。例如用  <code>v-bind</code>  指令来响应式地更新一个 HTML attribute：</p>\n<p>template</p>\n<pre><code>&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;\n\n&lt;!-- 简写 --&gt;\n&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>这里  <code>href</code>  就是一个参数，它告诉  <code>v-bind</code>  指令将表达式  <code>url</code>  的值绑定到元素的  <code>href</code>  attribute 上。在简写中，参数前的一切 (例如  <code>v-bind:</code> ) 都会被缩略为一个  <code>:</code>  字符。</p>\n<p>另一个例子是  <code>v-on</code>  指令，它将监听 DOM 事件：</p>\n<pre><code>&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n\n&lt;!-- 简写 --&gt;\n&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>这里的参数是要监听的事件名称： <code>click</code> 。 <code>v-on</code>  有一个相应的缩写，即  <code>@</code>  字符。我们之后也会讨论关于事件处理的更多细节。</p>\n<h3 id=\"动态参数\"><a class=\"anchor\" href=\"#动态参数\">#</a> 动态参数</h3>\n<p>同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</p>\n<p>template</p>\n<pre><code>&lt;!--\n注意，参数表达式有一些约束，\n参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释\n--&gt;\n&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;\n\n&lt;!-- 简写 --&gt;\n&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>这里的  <code>attributeName</code>  会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性  <code>attributeName</code> ，其值为  <code>&quot;href&quot;</code> ，那么这个绑定就等价于  <code>v-bind:href</code> 。</p>\n<p>相似地，你还可以将一个函数绑定到动态的事件名称上：</p>\n<p>template</p>\n<pre><code>&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n\n&lt;!-- 简写 --&gt;\n&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>在此示例中，当  <code>eventName</code>  的值是  <code>&quot;focus&quot;</code>  时， <code>v-on:[eventName]</code>  就等价于  <code>v-on:focus</code> 。</p>\n<h3 id=\"动态参数值的限制\"><a class=\"anchor\" href=\"#动态参数值的限制\">#</a> 动态参数值的限制</h3>\n<p>动态参数中表达式的值应当是一个字符串，或者是  <code>null</code> 。特殊值  <code>null</code>  意为显式移除该绑定。其他非字符串的值会触发警告。</p>\n<h3 id=\"动态参数语法的限制\"><a class=\"anchor\" href=\"#动态参数语法的限制\">#</a> 动态参数语法的限制</h3>\n<p>动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：</p>\n<p>template</p>\n<pre><code>&lt;!-- 这会触发一个编译器警告 --&gt;\n&lt;a :['foo' + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>如果你需要传入一个复杂的动态参数，我们推荐使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvZXNzZW50aWFscy9jb21wdXRlZC5odG1s\">计算属性</span>替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。</p>\n<p>当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：</p>\n<p>template</p>\n<pre><code>&lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;\n</code></pre>\n<p>上面的例子将会在 DOM 内嵌模板中被转换为  <code>:[someattr]</code> 。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板<strong>不</strong>受此限制。</p>\n<p><strong>完整的指令语法</strong></p>\n<p><img data-src=\"directive.DtZKvoAo.png\" alt=\"指令语法图\" /></p>\n<h1 id=\"响应式基础\"><a class=\"anchor\" href=\"#响应式基础\">#</a> 响应式基础</h1>\n<h2 id=\"声明响应式状态\"><a class=\"anchor\" href=\"#声明响应式状态\">#</a> 声明响应式状态</h2>\n<h3 id=\"ref\"><a class=\"anchor\" href=\"#ref\">#</a>  <code>ref()</code></h3>\n<p>在组合式 API 中，推荐使用 <a href=\"https://cn.vuejs.org/api/reactivity-core.html#ref\"> <code>ref()</code> </a> 函数来声明响应式状态：</p>\n<pre><code>import &#123; ref &#125; from 'vue'\n\nconst count = ref(0)\n</code></pre>\n<p><code>ref()</code>  接收参数，并将其包裹在一个带有  <code>.value</code>  属性的 ref 对象中返回：</p>\n<pre><code>const count = ref(0)\n\nconsole.log(count) // &#123; value: 0 &#125;\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n</code></pre>\n<blockquote>\n<p>参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvdHlwZXNjcmlwdC9jb21wb3NpdGlvbi1hcGkuaHRtbCN0eXBpbmctcmVm\">为 refs 标注类型</span></p>\n</blockquote>\n<p>要在组件模板中访问 ref，请从组件的  <code>setup()</code>  函数中声明并返回它们：</p>\n<p>js</p>\n<pre><code>import &#123; ref &#125; from 'vue'\n\nexport default &#123;\n  // `setup` 是一个特殊的钩子，专门用于组合式 API。\n  setup() &#123;\n    const count = ref(0)\n\n    // 将 ref 暴露给模板\n    return &#123;\n      count\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>template</p>\n<pre><code>&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;\n</code></pre>\n<p>注意，在模板中使用 ref 时，我们<strong>不</strong>需要附加  <code>.value</code> 。为了方便起见，当在模板中使用时，ref 会自动解包 (有一些<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvZXNzZW50aWFscy9yZWFjdGl2aXR5LWZ1bmRhbWVudGFscy5odG1sI2NhdmVhdC13aGVuLXVud3JhcHBpbmctaW4tdGVtcGxhdGVz\">注意事项</span>)。</p>\n<p>你也可以直接在事件监听器中改变一个 ref：</p>\n<p>template</p>\n<pre><code>&lt;button @click=&quot;count++&quot;&gt;\n  &#123;&#123; count &#125;&#125;\n&lt;/button&gt;\n</code></pre>\n<p>对于更复杂的逻辑，我们可以在同一作用域内声明更改 ref 的函数，并将它们作为方法与状态一起公开：</p>\n<p>js</p>\n<pre><code>import &#123; ref &#125; from 'vue'\n\nexport default &#123;\n  setup() &#123;\n    const count = ref(0)\n\n    function increment() &#123;\n      // 在 JavaScript 中需要 .value\n      count.value++\n    &#125;\n\n    // 不要忘记同时暴露 increment 函数\n    return &#123;\n      count,\n      increment\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>然后，暴露的方法可以被用作事件监听器：</p>\n<p>template</p>\n<pre><code>&lt;button @click=&quot;increment&quot;&gt;\n  &#123;&#123; count &#125;&#125;\n&lt;/button&gt;\n</code></pre>\n<p>这里是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlcGVuLmlvL3Z1ZWpzLWV4YW1wbGVzL3Blbi9XTlliYXFv\">Codepen</span> 上的例子，没有使用任何构建工具。</p>\n<h3 id=\"script-setup\"><a class=\"anchor\" href=\"#script-setup\">#</a>  <code>&lt;script setup&gt;</code></h3>\n<p>在  <code>setup()</code>  函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvc2NhbGluZy11cC9zZmMuaHRtbA==\">单文件组件 (SFC)</span> 来避免这种情况。我们可以使用  <code>&lt;script setup&gt;</code>  来大幅度地简化代码：</p>\n<p>vue</p>\n<pre><code>&lt;script setup&gt;\nimport &#123; ref &#125; from 'vue'\n\nconst count = ref(0)\n\nfunction increment() &#123;\n  count.value++\n&#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;button @click=&quot;increment&quot;&gt;\n    &#123;&#123; count &#125;&#125;\n  &lt;/button&gt;\n&lt;/template&gt;\n</code></pre>\n<p>&lt;script setup&gt; 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数 —— 它自然可以访问与它一起声明的所有内容。</p>\n<p>TIP</p>\n<p>在指南的后续章节中，我们基本上都会在组合式 API 示例中使用单文件组件 +  <code>&lt;script setup&gt;</code>  的语法，因为大多数 Vue 开发者都会这样使用。</p>\n<p>如果你没有使用单文件组件，你仍然可以在 <a href=\"https://cn.vuejs.org/api/composition-api-setup.html\"> <code>setup()</code> </a> 选项中使用组合式 API。</p>\n<h3 id=\"为什么要使用-ref\"><a class=\"anchor\" href=\"#为什么要使用-ref\">#</a> 为什么要使用 ref？</h3>\n<p>你可能会好奇：为什么我们需要使用带有  <code>.value</code>  的 ref，而不是普通的变量？为了解释这一点，我们需要简单地讨论一下 Vue 的响应式系统是如何工作的。</p>\n<p>当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会<strong>追踪</strong>在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会<strong>触发</strong>追踪它的组件的一次重新渲染。</p>\n<p>在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。</p>\n<p>该  <code>.value</code>  属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：</p>\n<p>js</p>\n<pre><code>// 伪代码，不是真正的实现\nconst myRef = &#123;\n  _value: 0,\n  get value() &#123;\n    track()\n    return this._value\n  &#125;,\n  set value(newValue) &#123;\n    this._value = newValue\n    trigger()\n  &#125;\n&#125;\n</code></pre>\n<p>另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。</p>\n<p>该响应性系统在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvZXh0cmFzL3JlYWN0aXZpdHktaW4tZGVwdGguaHRtbA==\">深入响应式原理</span>章节中有更详细的讨论。</p>\n<h3 id=\"深层响应性\"><a class=\"anchor\" href=\"#深层响应性\">#</a> 深层响应性</h3>\n<p>Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如  <code>Map</code> 。</p>\n<p>Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：</p>\n<p>js</p>\n<pre><code>import &#123; ref &#125; from 'vue'\n\nconst obj = ref(&#123;\n  nested: &#123; count: 0 &#125;,\n  arr: ['foo', 'bar']\n&#125;)\n\nfunction mutateDeeply() &#123;\n  // 以下都会按照期望工作\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n&#125;\n</code></pre>\n<p>非原始值将通过 <a href=\"https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive\"> <code>reactive()</code> </a> 转换为响应式代理，该函数将在后面讨论。</p>\n<p>也可以通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvYXBpL3JlYWN0aXZpdHktYWR2YW5jZWQuaHRtbCNzaGFsbG93cmVm\">shallow ref</span> 来放弃深层响应性。对于浅层 ref，只有  <code>.value</code>  的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。</p>\n<p>阅读更多：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvYmVzdC1wcmFjdGljZXMvcGVyZm9ybWFuY2UuaHRtbCNyZWR1Y2UtcmVhY3Rpdml0eS1vdmVyaGVhZC1mb3ItbGFyZ2UtaW1tdXRhYmxlLXN0cnVjdHVyZXM=\">减少大型不可变数据的响应性开销</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvZXh0cmFzL3JlYWN0aXZpdHktaW4tZGVwdGguaHRtbCNpbnRlZ3JhdGlvbi13aXRoLWV4dGVybmFsLXN0YXRlLXN5c3RlbXM=\">与外部状态系统集成</span></li>\n</ul>\n<h3 id=\"dom-更新时机\"><a class=\"anchor\" href=\"#dom-更新时机\">#</a> DOM 更新时机</h3>\n<p>当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在 “next tick” 更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。</p>\n<p>要等待 DOM 更新完成后再执行额外的代码，可以使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvYXBpL2dlbmVyYWwuaHRtbCNuZXh0dGljaw==\">nextTick()</span> 全局 API：</p>\n<p>js</p>\n<pre><code>import &#123; nextTick &#125; from 'vue'\n\nasync function increment() &#123;\n  count.value++\n  await nextTick()\n  // 现在 DOM 已经更新了\n&#125;\n</code></pre>\n<h2 id=\"reactive\"><a class=\"anchor\" href=\"#reactive\">#</a> <s> <code>reactive()</code> </s></h2>\n<p>...</p>\n<h2 id=\"额外的-ref-解包细节\"><a class=\"anchor\" href=\"#额外的-ref-解包细节\">#</a> 额外的 ref 解包细节</h2>\n<h3 id=\"作为-reactive-对象的属性\"><a class=\"anchor\" href=\"#作为-reactive-对象的属性\">#</a> 作为 reactive 对象的属性</h3>\n<p>一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性：</p>\n<p>js</p>\n<pre><code>const count = ref(0)\nconst state = reactive(&#123;\n  count\n&#125;)\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1\n</code></pre>\n<p>如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：</p>\n<p>js</p>\n<pre><code>const otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// 原始 ref 现在已经和 state.count 失去联系\nconsole.log(count.value) // 1\n</code></pre>\n<p>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvYXBpL3JlYWN0aXZpdHktYWR2YW5jZWQuaHRtbCNzaGFsbG93cmVhY3RpdmU=\">浅层响应式对象</span>的属性被访问时不会解包。</p>\n<h3 id=\"数组和集合的注意事项\"><a class=\"anchor\" href=\"#数组和集合的注意事项\">#</a> 数组和集合的注意事项</h3>\n<p>与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型 (如  <code>Map</code> ) 中的元素被访问时，它<strong>不会</strong>被解包：</p>\n<p>js</p>\n<pre><code>const books = reactive([ref('Vue 3 Guide')])\n// 这里需要 .value\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// 这里需要 .value\nconsole.log(map.get('count').value)\n</code></pre>\n<h3 id=\"在模板中解包的注意事项\"><a class=\"anchor\" href=\"#在模板中解包的注意事项\">#</a> 在模板中解包的注意事项</h3>\n<p>在模板渲染上下文中，只有顶级的 ref 属性才会被解包。</p>\n<p>在下面的例子中， <code>count</code>  和  <code>object</code>  是顶级属性，但  <code>object.id</code>  不是：</p>\n<p>js</p>\n<pre><code>const count = ref(0)\nconst object = &#123; id: ref(1) &#125;\n</code></pre>\n<p>因此，这个表达式按预期工作：</p>\n<p>template</p>\n<pre><code>&#123;&#123; count + 1 &#125;&#125;\n</code></pre>\n<p>... 但这个<strong>不会</strong>：</p>\n<p>template</p>\n<pre><code>&#123;&#123; object.id + 1 &#125;&#125;\n</code></pre>\n<p>渲染的结果将是  <code>[object Object]1</code> ，因为在计算表达式时  <code>object.id</code>  没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将  <code>id</code>  解构为一个顶级属性：</p>\n<p>js</p>\n<pre><code>const &#123; id &#125; = object\n</code></pre>\n<p>template</p>\n<pre><code>&#123;&#123; id + 1 &#125;&#125;\n</code></pre>\n<p>现在渲染的结果将是  <code>2</code> 。</p>\n<p>另一个需要注意的点是，如果 ref 是文本插值的最终计算值 (即  <code>&#123;&#123; &#125;&#125;</code>  标签)，那么它将被解包，因此以下内容将渲染为  <code>1</code> ：</p>\n<p>template</p>\n<pre><code>&#123;&#123; object.id &#125;&#125;\n</code></pre>\n<p>该特性仅仅是文本插值的一个便利特性，等价于  <code>&#123;&#123; object.id.value &#125;&#125;</code> 。</p>\n<h1 id=\"计算属性\"><a class=\"anchor\" href=\"#计算属性\">#</a> 计算属性</h1>\n<h2 id=\"基础示例\"><a class=\"anchor\" href=\"#基础示例\">#</a> 基础示例</h2>\n<p>模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：</p>\n<p>js</p>\n<pre><code>const author = reactive(&#123;\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n&#125;)\n</code></pre>\n<p>我们想根据  <code>author</code>  是否已有一些书籍来展示不同的信息：</p>\n<p>template</p>\n<pre><code>&lt;p&gt;Has published books:&lt;/p&gt;\n&lt;span&gt;&#123;&#123; author.books.length > 0 ? 'Yes' : 'No' &#125;&#125;&lt;/span&gt;\n</code></pre>\n<p>这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于  <code>author.books</code> 。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。</p>\n<p>因此我们推荐使用<strong>计算属性</strong>来描述依赖响应式状态的复杂逻辑。这是重构后的示例：</p>\n<p>vue</p>\n<pre><code>&lt;script setup&gt;\nimport &#123; reactive, computed &#125; from 'vue'\n\nconst author = reactive(&#123;\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n&#125;)\n\n// 一个计算属性 ref\nconst publishedBooksMessage = computed(() =&gt; &#123;\n  return author.books.length &gt; 0 ? 'Yes' : 'No'\n&#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;p&gt;Has published books:&lt;/p&gt;\n  &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;\n&lt;/template&gt;\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbGF5LnZ1ZWpzLm9yZy8jZU5wMWtFOUx3MEFReGIvS0k1ZHRvVGFpbmtvYWFSRVVvWjVFRU9OaG0weWJZTE83N0o5Q0NmbnV6dGEwdmRqYnpyNlplYjk1WGJJd1pyb1BsTXlTekpXMk1SNk9mREI1b1pyV2FPdlJ3WklzZmJPbkNVcmRtdUNwUW8rTjFTMEVUNHBDRmFyVXlubkk0R3R0TVQ5UGpMcENBVXEyTklONDFiWENreVl4aVo5cnJYL2NERi94RFlpUFFMakREUmJWWHFxU0haNURVdzJ0ZzN6UDhsSzZwdnhIZTJEdHZTYXNEczZUUFRBVDhGMm9maHpoMGhUeWdtNXBjK0kxWWIxclhFM1ZNc0tzeURtNUpjWS85WTVHWTh4ekhJK3duSXBWdzRuVEkvMTBSMnJyYStTNHhTUEVKemtCdnZOTnMzMTB6dEsvUkRsTExqeTFaaWM5Y1FWa0puK1I3Z0l3eEpHbE1YaVduWkVxNzdvcmhIM1BxMk5IOURqdlRmcGZTQlNibUE9PQ==\">在演练场中尝试一下</span></p>\n<p>我们在这里定义了一个计算属性  <code>publishedBooksMessage</code> 。 <code>computed()</code>  方法期望接收一个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2dldCNkZXNjcmlwdGlvbg==\">getter 函数</span>，返回值为一个<strong>计算属性 ref</strong>。和其他一般的 ref 类似，你可以通过  <code>publishedBooksMessage.value</code>  访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加  <code>.value</code> 。</p>\n<p>Vue 的计算属性会自动追踪响应式依赖。它会检测到  <code>publishedBooksMessage</code>  依赖于  <code>author.books</code> ，所以当  <code>author.books</code>  改变时，任何依赖于  <code>publishedBooksMessage</code>  的绑定都会同时更新。</p>\n<p>也可参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvdHlwZXNjcmlwdC9jb21wb3NpdGlvbi1hcGkuaHRtbCN0eXBpbmctY29tcHV0ZWQ=\">为计算属性标注类型</span></p>\n<h2 id=\"计算属性缓存-vs-方法\"><a class=\"anchor\" href=\"#计算属性缓存-vs-方法\">#</a> 计算属性缓存 vs 方法</h2>\n<p>你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</p>\n<p>template</p>\n<pre><code>&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt;\n</code></pre>\n<p>js</p>\n<pre><code>// 组件中\nfunction calculateBooksMessage() &#123;\n  return author.books.length &gt; 0 ? 'Yes' : 'No'\n&#125;\n</code></pre>\n<p>若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于<strong>计算属性值会基于其响应式依赖被缓存</strong>。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要  <code>author.books</code>  不改变，无论多少次访问  <code>publishedBooksMessage</code>  都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p>\n<p>这也解释了为什么下面的计算属性永远不会更新，因为  <code>Date.now()</code>  并不是一个响应式依赖：</p>\n<p>js</p>\n<pre><code>const now = computed(() =&gt; Date.now())\n</code></pre>\n<p>相比之下，方法调用<strong>总是</strong>会在重渲染发生时再次执行函数。</p>\n<p>为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性  <code>list</code> ，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于  <code>list</code> 。没有缓存的话，我们会重复执行非常多次  <code>list</code>  的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p>\n<h2 id=\"可写计算属性\"><a class=\"anchor\" href=\"#可写计算属性\">#</a> 可写计算属性</h2>\n<p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到 “可写” 的属性，你可以通过同时提供 getter 和 setter 来创建：</p>\n<p>vue</p>\n<pre><code>&lt;script setup&gt;\nimport &#123; ref, computed &#125; from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed(&#123;\n  // getter\n  get() &#123;\n    return firstName.value + ' ' + lastName.value\n  &#125;,\n  // setter\n  set(newValue) &#123;\n    // 注意：我们这里使用的是解构赋值语法\n    [firstName.value, lastName.value] = newValue.split(' ')\n  &#125;\n&#125;)\n&lt;/script&gt;\n</code></pre>\n<p>现在当你再运行  <code>fullName.value = 'John Doe'</code>  时，setter 会被调用而  <code>firstName</code>  和  <code>lastName</code>  会随之更新。</p>\n<h2 id=\"最佳实践\"><a class=\"anchor\" href=\"#最佳实践\">#</a> 最佳实践</h2>\n<h3 id=\"getter-不应有副作用\"><a class=\"anchor\" href=\"#getter-不应有副作用\">#</a> Getter 不应有副作用</h3>\n<p>计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，<strong>不要改变其他状态、在 getter 中做异步请求或者更改 DOM</strong>！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvZXNzZW50aWFscy93YXRjaGVycy5odG1s\">侦听器</span>根据其他响应式状态的变更来创建副作用。</p>\n<h3 id=\"避免直接修改计算属性值\"><a class=\"anchor\" href=\"#避免直接修改计算属性值\">#</a> 避免直接修改计算属性值</h3>\n<p>从计算属性返回的值是派生状态。可以把它看作是一个 “临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改 —— 应该更新它所依赖的源状态以触发新的计算。</p>\n<h1 id=\"class-与-style-绑定\"><a class=\"anchor\" href=\"#class-与-style-绑定\">#</a> Class 与 Style 绑定</h1>\n<p>数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为  <code>class</code>  和  <code>style</code>  都是 attribute，我们可以和其他 attribute 一样使用  <code>v-bind</code>  将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为  <code>class</code>  和  <code>style</code>  的  <code>v-bind</code>  用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p>\n<h2 id=\"绑定-html-class\"><a class=\"anchor\" href=\"#绑定-html-class\">#</a> 绑定 HTML class</h2>\n<h3 id=\"绑定一个返回对象\"><a class=\"anchor\" href=\"#绑定一个返回对象\">#</a> 绑定一个返回对象</h3>\n<p>我们也可以绑定一个返回对象的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvZXNzZW50aWFscy9jb21wdXRlZC5odG1s\">计算属性</span>。这是一个常见且很有用的技巧：</p>\n<p>js</p>\n<pre><code>const isActive = ref(true)\nconst error = ref(null)\n\nconst classObject = computed(() =&gt; (&#123;\n  active: isActive.value &amp;&amp; !error.value,\n  'text-danger': error.value &amp;&amp; error.value.type === 'fatal'\n&#125;))\n</code></pre>\n<p>template</p>\n<pre><code>&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id=\"绑定数组\"><a class=\"anchor\" href=\"#绑定数组\">#</a> 绑定数组</h3>\n<p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p>\n<p>template</p>\n<pre><code>&lt;div :class=&quot;[&#123; [activeClass]: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h2 id=\"绑定内联样式\"><a class=\"anchor\" href=\"#绑定内联样式\">#</a> 绑定内联样式</h2>\n<h3 id=\"样式多值\"><a class=\"anchor\" href=\"#样式多值\">#</a> 样式多值</h3>\n<p>你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：</p>\n<p>template</p>\n<pre><code>&lt;div :style=&quot;&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要<strong>特别前缀</strong>的浏览器中都会渲染为  <code>display: flex</code> 。</p>\n<h1 id=\"条件渲染\"><a class=\"anchor\" href=\"#条件渲染\">#</a> 条件渲染</h1>\n<h2 id=\"v-else-if\"><a class=\"anchor\" href=\"#v-else-if\">#</a>  <code>v-else-if</code></h2>\n<p>顾名思义， <code>v-else-if</code>  提供的是相应于  <code>v-if</code>  的 “else if 区块”。它可以连续多次重复使用：</p>\n<p>template</p>\n<pre><code>&lt;div v-if=&quot;type === 'A'&quot;&gt;\n  A\n&lt;/div&gt;\n&lt;div v-else-if=&quot;type === 'B'&quot;&gt;\n  B\n&lt;/div&gt;\n&lt;div v-else-if=&quot;type === 'C'&quot;&gt;\n  C\n&lt;/div&gt;\n&lt;div v-else&gt;\n  Not A/B/C\n&lt;/div&gt;\n</code></pre>\n<h2 id=\"template-上的-v-if\"><a class=\"anchor\" href=\"#template-上的-v-if\">#</a>  <code>&lt;template&gt;</code>  上的  <code>v-if</code></h2>\n<p>因为  <code>v-if</code>  是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个  <code>&lt;template&gt;</code>  元素上使用  <code>v-if</code> ，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个  <code>&lt;template&gt;</code>  元素。</p>\n<p>template</p>\n<pre><code>&lt;template v-if=&quot;ok&quot;&gt;\n  &lt;h1&gt;Title&lt;/h1&gt;\n  &lt;p&gt;Paragraph 1&lt;/p&gt;\n  &lt;p&gt;Paragraph 2&lt;/p&gt;\n&lt;/template&gt;\n</code></pre>\n<p><code>v-else</code>  和  <code>v-else-if</code>  也可以在  <code>&lt;template&gt;</code>  上使用。</p>\n<h2 id=\"v-show\"><a class=\"anchor\" href=\"#v-show\">#</a>  <code>v-show</code> []</h2>\n<p>另一个可以用来按条件显示一个元素的指令是  <code>v-show</code> 。其用法基本一样：</p>\n<p>template</p>\n<pre><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;\n</code></pre>\n<p>不同之处在于  <code>v-show</code>  会在 DOM 渲染中保留该元素； <code>v-show</code>  仅切换了该元素上名为  <code>display</code>  的 CSS 属性。</p>\n<p><code>v-show</code>  不支持在  <code>&lt;template&gt;</code>  元素上使用，也不能和  <code>v-else</code>  搭配使用。</p>\n<h2 id=\"v-if-vs-v-show\"><a class=\"anchor\" href=\"#v-if-vs-v-show\">#</a>  <code>v-if</code>  vs.  <code>v-show</code> []</h2>\n<p><code>v-if</code>  是 “真实的” 按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p>\n<p><code>v-if</code>  也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p>\n<p>相比之下， <code>v-show</code>  简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS  <code>display</code>  属性会被切换。</p>\n<p>总的来说， <code>v-if</code>  有<strong>更高的切换开销</strong>，而  <code>v-show</code>  有<strong>更高的初始渲染开销</strong>。因此，如果需要频繁切换，则使用  <code>v-show</code>  较好；如果在运行时绑定条件很少改变，则  <code>v-if</code>  会更合适。</p>\n<h2 id=\"v-if-和-v-for\"><a class=\"anchor\" href=\"#v-if-和-v-for\">#</a>  <code>v-if</code>  和  <code>v-for</code> []</h2>\n<p>警告</p>\n<p>同时使用  <code>v-if</code>  和  <code>v-for</code>  是<strong>不推荐的</strong>，因为这样二者的优先级不明显。请查看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvc3R5bGUtZ3VpZGUvcnVsZXMtZXNzZW50aWFsLmh0bWwjYXZvaWQtdi1pZi13aXRoLXYtZm9y\">风格指南</span>获得更多信息。</p>\n<p>当  <code>v-if</code>  和  <code>v-for</code>  同时存在于一个元素上的时候， <code>v-if</code>  会首先被执行。请查看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvZ3VpZGUvZXNzZW50aWFscy9saXN0Lmh0bWwjdi1mb3Itd2l0aC12LWlm\">列表渲染指南</span>获取更多细节。</p>\n<h1 id=\"列表渲染\"><a class=\"anchor\" href=\"#列表渲染\">#</a> 列表渲染</h1>\n<h2 id=\"v-for\"><a class=\"anchor\" href=\"#v-for\">#</a>  <code>v-for</code></h2>\n<p>在  <code>v-for</code>  块中可以完整地访问父作用域内的属性和变量。 <code>v-for</code>  也支持使用可选的第二个参数表示当前项的位置索引。</p>\n<p>js</p>\n<pre><code>const parentMessage = ref('Parent')\nconst items = ref([&#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125;])\n</code></pre>\n<p>template</p>\n<pre><code>&lt;li v-for=&quot;(item, index) in items&quot;&gt;\n  &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;\n&lt;/li&gt;\n</code></pre>\n<h3 id=\"使用解构\"><a class=\"anchor\" href=\"#使用解构\">#</a> 使用解构</h3>\n<p>注意  <code>v-for</code>  是如何对应  <code>forEach</code>  回调的函数签名的。实际上，你也可以在定义  <code>v-for</code>  的变量别名时<strong>使用解构</strong>，和解构函数参数类似：</p>\n<p>template</p>\n<pre><code>&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt;\n\t// message是item的属性名，可解构\n  &#123;&#123; message &#125;&#125;\n&lt;/li&gt;\n\n&lt;!-- 有 index 索引时 --&gt;\n&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt;\n  &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;\n&lt;/li&gt;\n</code></pre>\n<h2 id=\"v-for-与对象\"><a class=\"anchor\" href=\"#v-for-与对象\">#</a>  <code>v-for</code>  与对象</h2>\n<p>你也可以使用  <code>v-for</code>  来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用  <code>Object.values()</code>  的返回值来决定。</p>\n<pre><code>&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;\n  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;\n&lt;/li&gt;\n</code></pre>\n<h2 id=\"在-v-for-里使用范围值\"><a class=\"anchor\" href=\"#在-v-for-里使用范围值\">#</a> 在  <code>v-for</code>  里使用范围值</h2>\n<p><code>v-for</code>  可以直接接受一个整数值。在这种用例中，会将该模板基于  <code>1...n</code>  的取值范围重复多次。</p>\n<p>template</p>\n<pre><code>&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;\n</code></pre>\n<p>注意此处  <code>n</code>  的初值是从  <code>1</code>  开始而非  <code>0</code> 。</p>\n<h2 id=\"通过-key-管理状态\"><a class=\"anchor\" href=\"#通过-key-管理状态\">#</a> 通过 key 管理状态</h2>\n<p>Vue 默认按照 “就地更新” 的策略来更新通过  <code>v-for</code>  渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p>\n<p>默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p>\n<p>为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，<strong>从而重用和重新排序现有的元素</strong>，你需要为每个元素对应的块提供一个唯一的  <code>key</code>  attribute：</p>\n<p>template</p>\n<pre><code>&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;\n  &lt;!-- 内容 --&gt;\n&lt;/div&gt;\n</code></pre>\n<p>注意</p>\n<p><code>key</code>  在这里是一个通过  <code>v-bind</code>  绑定的特殊 attribute。请不要和<a href=\"https://cn.vuejs.org/guide/essentials/list.html#v-for-with-an-object\">在  <code>v-for</code>  中使用对象</a>里所提到的对象属性名相混淆。</p>\n<h1 id=\"续\"><a class=\"anchor\" href=\"#续\">#</a> 续</h1>\n<h2 id=\"reactive响应式对象\"><a class=\"anchor\" href=\"#reactive响应式对象\">#</a> reactive 响应式对象</h2>\n<p>不能重新赋值一个对象，可以借用 Object.assign ()</p>\n<p>ref () 则可以修改  <code>car.value  = &#123;…&#125;</code></p>\n<p><img data-src=\"image-20240830134823308.png\" alt=\"image-20240830134823308\" /></p>\n<p><strong>使用原则:</strong></p>\n<ul>\n<li>若需要一个基本类型的响应式数据，必须使用 ref</li>\n<li>若需要一个响应式对象，层级不深， ref、reactive 都可以</li>\n<li>若需要一个响应式对象，且层级较深推荐使用 reactive</li>\n</ul>\n<p><strong>toRefs / toRef</strong></p>\n<pre><code>Obj obj = toRefs(obj)\n\nParam p = toRef(obj, param)\n</code></pre>\n<h2 id=\"计算属性-2\"><a class=\"anchor\" href=\"#计算属性-2\">#</a> 计算属性</h2>\n<p><img data-src=\"image-20240830140740409.png\" alt=\"image-20240830140740409\" /></p>\n<h2 id=\"路由\"><a class=\"anchor\" href=\"#路由\">#</a> 路由</h2>\n",
            "tags": [
                "Vue3"
            ]
        },
        {
            "id": "http://example.com/2023/12/11/todolist/",
            "url": "http://example.com/2023/12/11/todolist/",
            "title": "todolist",
            "date_published": "2023-12-11T08:52:51.000Z",
            "content_html": "<p>这两周是实践周，跟着老师做点东西</p>\n<p>相对简单的是，用 vue 框架做一个简单的待办清单</p>\n<h1 id=\"步骤\"><a class=\"anchor\" href=\"#步骤\">#</a> 步骤</h1>\n<p>结合 bootstrap 框架做了如下待办清单</p>\n<p>首先用 npm 新建一个项目（需要 npm）</p>\n<pre><code>npm init vite-app todolist\n//安装需要的依赖\nnpm install\n//启动\nnpm run dev\n</code></pre>\n<p>其中，Bootstrap 需要从官方下载（可 git clone）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL3JlbGVhc2VzL2Rvd25sb2FkL3Y0LjYuMi9ib290c3RyYXAtNC42LjItZGlzdC56aXA=\">https://github.com/twbs/bootstrap/releases/download/v4.6.2/bootstrap-4.6.2-dist.zip</span></p>\n<pre><code>结构\ntodolist\n--node_modules //依赖库\n--public\n--src\n----assets //Bootstrap放这\n----components //存放部件\n------todoButton.vue //todolist的按钮\n------todoInput.vue //todolist的输入\n------todoList.vue //todolist的列表\n----App.vue // 主界面\n----index.css\n----main.js // 启动入口\n--...\n</code></pre>\n<p>todoButton.vue</p>\n<pre><code>&lt;template&gt;\n\t&lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;Basic example&quot;&gt;\n\t\t&lt;button type=&quot;button&quot; class=&quot;btn&quot; :class=&quot;active === 0 ? 'btn-primary' : btn-secondary&quot;\n\t\t\t@click=&quot;changeActive(0)&quot;&gt;全部&lt;/button&gt;\n\t\t&lt;button type=&quot;button&quot; class=&quot;btn&quot; :class=&quot;active === 1 ? 'btn-primary' : btn-secondary&quot;\n\t\t\t@click=&quot;changeActive(1)&quot;&gt;已完成&lt;/button&gt;\n\t\t&lt;button type=&quot;button&quot; class=&quot;btn&quot; :class=&quot;active === 2 ? 'btn-primary' : btn-secondary&quot;\n\t\t\t@click=&quot;changeActive(2)&quot;&gt;未完成&lt;/button&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default &#123;\n\t\tname: &quot;todoButton&quot;,\n\t\tdata() &#123;\n\t\t\treturn &#123;\n\t\t\t\tactive: 0,\n\t\t\t&#125;;\n\t\t&#125;,\n\t\temits: [&quot;changeActive&quot;],\n\t\tmethods: &#123;\n\t\t\tchangeActive(index) &#123;\n\t\t\t\tthis.active = index;\n\t\t\t\tthis.$emit(&quot;changeActive&quot;, index);\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n\t.btn-group &#123;\n\t\twidth: 20%;\n\t\tmargin: 20px auto;\n\t&#125;\n&lt;/style&gt;\n</code></pre>\n<p>todoInput.vue</p>\n<pre><code>&lt;template&gt;\n\t&lt;div class=&quot;input-group mb-3&quot;&gt;\n\t\t&lt;div class=&quot;input-group-prepend&quot;&gt;\n\t\t\t&lt;button class=&quot;btn-primary&quot; @click=&quot;onsubmit&quot;&gt;提交&lt;/button&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;添加任务&quot; aria-label=&quot;Username&quot; aria-describedby=&quot;basic-addon1&quot;\n\t\t\tv-model=&quot;taskname&quot;&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default &#123;\n\t\tname: &quot;todoInput&quot;,\n\t\tdata() &#123;\n\t\t\treturn &#123;\n\t\t\t\ttaskname: &quot;&quot;,\n\t\t\t&#125;;\n\t\t&#125;,\n\t\temits: [&quot;addTask&quot;],\n\t\tmethods: &#123;\n\t\t\tonsubmit() &#123;\n\t\t\t\tthis.$emit(&quot;addTask&quot;, this.taskname);\n\t\t\t\tthis.taskname = &quot;&quot;;\n\t\t\t&#125;\n\t\t&#125;,\n\t&#125;;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n\t.input-group &#123;\n\t\twidth: 40%;\n\t\tmargin: 20px auto;\n\t&#125;\n&lt;/style&gt;\n</code></pre>\n<p>todoList.vue</p>\n<pre><code>&lt;template&gt;\n\t&lt;ul class=&quot;list-group&quot;&gt;\n\t\t&lt;li class=&quot;list-group-item d-flex justify-content-between align-items-center&quot; v-for=&quot;item in todolist&quot; :\n\t\t\tkey=&quot;item.id&quot;&gt;\n\t\t\t&lt;!-- 复选框 --&gt;\n\t\t\t&lt;div class=&quot;form-check&quot;&gt;\n\t\t\t\t&lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot; value=&quot;&quot; :id=&quot;item.id&quot; v-model=&quot;item.isCompleted&quot;&gt;\n\t\t\t\t&lt;label class=&quot;form-check-label&quot; :for=&quot;item.id&quot; :class=&quot;item.isCompleted ? 'delete' : ''&quot;&gt;\n\t\t\t\t\t&#123;&#123; item.task &#125;&#125;\n\t\t\t\t&lt;/label&gt;\n\t\t\t&lt;/div&gt;\n\t\t\t&lt;span class=&quot;badge badge-success badge-pill&quot; v-if=&quot;item.isCompleted&quot;&gt;已完成&lt;/span&gt;\n\t\t\t&lt;span class=&quot;badge badge-warning badge-pill&quot; v-else&gt;未完成&lt;/span&gt;\n\t\t&lt;/li&gt;\n\t&lt;/ul&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\texport default &#123;\n\t\tname: 'todoList',\n\t\tprops: &#123;\n\t\t\ttodolist: &#123;\n\t\t\t\ttype: Array,\n\t\t\t\trequired: true,\n\t\t\t\tdefault: [],\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n\t.list-group &#123;\n\t\twidth: 40%;\n\t\tmargin: 20px auto;\n\t&#125;\n\n\t.delete &#123;\n\t\ttext-decoration: line-through;\n\t&#125;\n&lt;/style&gt;\n</code></pre>\n<p>App.vue</p>\n<pre><code>&lt;template&gt;\n\t&lt;div id=&quot;app&quot;&gt;\n\t\t&lt;h1&gt;TodoList&lt;/h1&gt;\n\t\t&lt;h6&gt;edit by Chen&lt;/h6&gt;\n\t\t&lt;!-- @ 用于处理事件，而 : 用于处理属性绑定。这两个符号都是Vue.js中的常见语法糖，使代码更简洁易读 --&gt;\n\t\t&lt;!-- @ 符号是 v-on 指令的缩写。它用于监听DOM事件并触发相应的Vue实例中的方法。 --&gt;\n\t\t&lt;!-- : 符号是 v-bind 指令的缩写。它用于动态绑定属性或表达式 --&gt;\n\t\t&lt;!-- 查自chatgpt 2023/12/11 --&gt;\n\t\t&lt;todoInput @addTask=&quot;addTask&quot;&gt;&lt;/todoInput&gt;\n\t\t&lt;todoList :todolist=&quot;todoList&quot;&gt;&lt;/todoList&gt;\n\t\t&lt;todoButton @changeActive=&quot;changeActive&quot;&gt;&lt;/todoButton&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\timport todoList from './components/todoList.vue'\n\timport todoButton from './components/todoButton.vue'\n\timport todoInput from './components/todoInput.vue'\n\n\texport default &#123;\n\t\tname: &quot;App&quot;,\n\t\tdata() &#123;\n\t\t\treturn &#123;\n\t\t\t\t// 假数据\n\t\t\t\ttodoList: [&#123;\n\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\ttask: '吃饭',\n\t\t\t\t\t\tisCompleted: true\n\t\t\t\t\t&#125;,\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\ttask: '嘻嘻嘻',\n\t\t\t\t\t\tisCompleted: false\n\t\t\t\t\t&#125;,\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tid: 3,\n\t\t\t\t\t\ttask: 'zzzzzzzz',\n\t\t\t\t\t\tisCompleted: true\n\t\t\t\t\t&#125;,\n\t\t\t\t],\n\t\t\t\tactive: 0,\n\t\t\t&#125;;\n\t\t&#125;,\n\t\tcomputed: &#123;\n\t\t\ttodoList() &#123;\n\t\t\t\tif (this.active === 0) &#123;\n\t\t\t\t\treturn this.todoList;\n\t\t\t\t&#125; else if (this.active === 1) &#123;\n\t\t\t\t\treturn this.todoList.filter(item =&gt; item.isCompleted);\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\treturn this.todoList.filter(item =&gt; !item.isCompleted);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;,\n\t\tmethods: &#123;\n\t\t\tchangeActive(active) &#123;\n\t\t\t\tthis.active = active;\n\t\t\t\tconsole.log(this.active);\n\t\t\t&#125;,\n\t\t\taddTask(taskname) &#123;\n\t\t\t\tthis.todoList.push(&#123;\n\t\t\t\t\tid: this.todoList.length + 1,\n\t\t\t\t\ttask: taskname,\n\t\t\t\t\tisCompleted: false,\n\t\t\t\t&#125;)\n\t\t\t&#125;,\n\t\t&#125;,\n\t\tcomponents: &#123;\n\t\t\ttodoList,\n\t\t\ttodoButton,\n\t\t\ttodoInput\n\t\t&#125;\n\t&#125;\n&lt;/script&gt;\n</code></pre>\n<p>main.vue</p>\n<pre><code>import &#123; createApp &#125; from 'vue'\nimport App from './App.vue'\nimport './assets/css/bootstrap.css'\nimport './index.css'\n\ncreateApp(App).mount('#app')\n\n</code></pre>\n",
            "tags": [
                "vue3"
            ]
        }
    ]
}